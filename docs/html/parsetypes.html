<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 13.1.1"/>
    <title>parsetypes API documentation</title>
            <link rel="icon" href="favicon.png"/>
	<script type="module">
		document.addEventListener('DOMContentLoaded', () => {
			// Remove all hyperlinks inside code blocks
			document.querySelectorAll('.pdoc .docstring pre code a, .pdoc .summary pre code a').forEach((a) => a.removeAttribute('href'));

			// Do not link to the current section from within its own docstring
			document.querySelectorAll('.pdoc .docstring a, .pdoc .attr a, .pdoc .summary a').forEach((a) => {
				const href = a.getAttribute('href');
				if (href === null) return;
				const hrefParts = href.split('#');
				if (hrefParts.length < 2) return;

				const id = hrefParts[1];
				const target = document.getElementById(id);
				if (target?.contains(a)) {
					a.removeAttribute('href');
				}
			});
		});
	</script>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;z-index:999;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{cursor:pointer;display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .view-value-toggle-state,.pdoc .view-value-toggle-state ~ .default_value{display:none;}.pdoc .view-value-toggle-state:checked ~ .default_value{display:inherit;}.pdoc .view-value-button{font-size:.5rem;vertical-align:middle;border-style:dashed;margin-top:-0.1rem;}.pdoc .view-value-button:hover{background:white;}.pdoc .view-value-button::before{content:"show";text-align:center;width:2.2em;display:inline-block;}.pdoc .view-value-toggle-state:checked ~ .view-value-button::before{content:"hide";}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */nav.pdoc .attribution{	font-size:small;	display:none;}nav.pdoc .attribution img{	height:2em;	width:unset;	margin-left:0.1em;}nav.pdoc .function::after{	content:none;}.pdoc > section:not(.module-info) h2{	font-size:1.3rem;}.pdoc code{	padding:0.2em 0.2em;}.pdoc pre{	tab-size:4;}.pdoc section{	margin-bottom:2.25rem;}.pdoc .classattr, .pdoc .inherited{	margin-top:2.25rem;	margin-bottom:2.25rem;}.pdoc .docstring{	margin-bottom:1rem;}.pdoc .docstring .pdoc-code{	margin-left:unset;	margin-right:unset;}.pdoc .attr{	font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;	tab-size:4;}.pdoc .decorator{	color:var(--muted);}</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>




            <h2>API Documentation</h2>
            	<ul class="memberlist">
			<li>
					<a class="class" href="#TypeParser">TypeParser</a>
							<ul class="memberlist">
            			<li>
            						<a class="function" href="#TypeParser.__init__">TypeParser</a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.is_none">is_none<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.is_bool">is_bool<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.is_int">is_int<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.is_float">is_float<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.is_decimal">is_decimal<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_none">parse_none<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_bool">parse_bool<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_int">parse_int<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_float">parse_float<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_decimal">parse_decimal<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.infer">infer<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.infer_series">infer_series<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.infer_table">infer_table<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.convert">convert<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse">parse<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_series">parse_series<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.parse_table">parse_table<span class="decorator">()</span></a>
            			</li>
            			<li>
            						<a class="function" href="#TypeParser.iterate_table">iterate_table<span class="decorator">()</span></a>
            			</li>
            	</ul>

			</li>
			<li>
						<a class="function" href="#reduce_types">reduce_types<span class="decorator">()</span></a>
			</li>
			<li>
					<a class="class" href="#Nullable">Nullable</a>
							<ul class="memberlist">
            	</ul>

			</li>
	</ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                        <a class="pdoc-button git-button" href="https://github.com/yushiyangk/parsetypes/blob/main/src/parsetypes/__init__.py">Edit on GitHub</a>
                    <h1 class="modulename">
parsetypes    </h1>

                <div class="docstring">
<p>This package provides tools for parsing serialised data to recover their original underlying types.</p>

<p>The <code><a href="#TypeParser">TypeParser</a></code> class provides configurable type inference and parsing. This can be initialised with different settings to, for example:</p>

<ul>
<li>treat <code>inf</code> as either a float or a normal string</li>
<li>give exact Decimal values instead of floats</li>
<li>detect inline lists</li>
</ul></div>

                        <input id="mod-parsetypes-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">

                        <label class="view-source-button" for="mod-parsetypes-view-source"><span>View Source</span></label>

                        <div class="pdoc-code codehilite"><pre><span></span><span id="L-1"><a href="#L-1"><span class="linenos"> 1</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos"> 2</span></a><span class="sd">	This package provides tools for parsing serialised data to recover their original underlying types.</span>
</span><span id="L-3"><a href="#L-3"><span class="linenos"> 3</span></a>
</span><span id="L-4"><a href="#L-4"><span class="linenos"> 4</span></a><span class="sd">	The `TypeParser` class provides configurable type inference and parsing. This can be initialised with different settings to, for example:</span>
</span><span id="L-5"><a href="#L-5"><span class="linenos"> 5</span></a><span class="sd">	- treat `inf` as either a float or a normal string</span>
</span><span id="L-6"><a href="#L-6"><span class="linenos"> 6</span></a><span class="sd">	- give exact Decimal values instead of floats</span>
</span><span id="L-7"><a href="#L-7"><span class="linenos"> 7</span></a><span class="sd">	- detect inline lists</span>
</span><span id="L-8"><a href="#L-8"><span class="linenos"> 8</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-9"><a href="#L-9"><span class="linenos"> 9</span></a>
</span><span id="L-10"><a href="#L-10"><span class="linenos">10</span></a>
</span><span id="L-11"><a href="#L-11"><span class="linenos">11</span></a><span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.3&quot;</span>
</span><span id="L-12"><a href="#L-12"><span class="linenos">12</span></a>
</span><span id="L-13"><a href="#L-13"><span class="linenos">13</span></a><span class="kn">from</span> <span class="nn">._common</span> <span class="kn">import</span> <span class="n">AnyScalar</span><span class="p">,</span> <span class="n">AnyScalarType</span><span class="p">,</span> <span class="n">AnyValue</span><span class="p">,</span> <span class="n">AnyValueType</span><span class="p">,</span> <span class="n">GenericValue</span><span class="p">,</span> <span class="n">Nullable</span>
</span><span id="L-14"><a href="#L-14"><span class="linenos">14</span></a><span class="kn">from</span> <span class="nn">._parser</span> <span class="kn">import</span> <span class="n">TypeParser</span>
</span><span id="L-15"><a href="#L-15"><span class="linenos">15</span></a><span class="kn">from</span> <span class="nn">._reduce_types</span> <span class="kn">import</span> <span class="n">reduce_types</span>
</span><span id="L-16"><a href="#L-16"><span class="linenos">16</span></a>
</span><span id="L-17"><a href="#L-17"><span class="linenos">17</span></a><span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;TypeParser&#39;</span><span class="p">,</span> <span class="s1">&#39;reduce_types&#39;</span><span class="p">,</span> <span class="s1">&#39;Nullable&#39;</span><span class="p">)</span>
</span></pre></div>


            </section>
                <section id="TypeParser">
                            <input id="TypeParser-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">TypeParser</span>:


                <label class="view-source-button" for="TypeParser-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser-60"><a href="#TypeParser-60"><span class="linenos">  60</span></a><span class="k">class</span> <span class="nc">TypeParser</span><span class="p">:</span>
</span><span id="TypeParser-61"><a href="#TypeParser-61"><span class="linenos">  61</span></a><span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-62"><a href="#TypeParser-62"><span class="linenos">  62</span></a><span class="sd">		A parser that can be used to infer the underlying types of data serialised as strings, and to convert them into their original underlying types.</span>
</span><span id="TypeParser-63"><a href="#TypeParser-63"><span class="linenos">  63</span></a>
</span><span id="TypeParser-64"><a href="#TypeParser-64"><span class="linenos">  64</span></a><span class="sd">		The behaviour of the parser and the type inference can be configured either in the constructor or using mutable properties of a parser instance. See the constructor documentation for the list of available options.</span>
</span><span id="TypeParser-65"><a href="#TypeParser-65"><span class="linenos">  65</span></a><span class="sd">	&quot;&quot;&quot;</span>
</span><span id="TypeParser-66"><a href="#TypeParser-66"><span class="linenos">  66</span></a>
</span><span id="TypeParser-67"><a href="#TypeParser-67"><span class="linenos">  67</span></a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
</span><span id="TypeParser-68"><a href="#TypeParser-68"><span class="linenos">  68</span></a>		<span class="o">*</span><span class="p">,</span>
</span><span id="TypeParser-69"><a href="#TypeParser-69"><span class="linenos">  69</span></a>		<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="TypeParser-70"><a href="#TypeParser-70"><span class="linenos">  70</span></a>		<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser-71"><a href="#TypeParser-71"><span class="linenos">  71</span></a>		<span class="n">list_delimiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span><span id="TypeParser-72"><a href="#TypeParser-72"><span class="linenos">  72</span></a>		<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
</span><span id="TypeParser-73"><a href="#TypeParser-73"><span class="linenos">  73</span></a>		<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser-74"><a href="#TypeParser-74"><span class="linenos">  74</span></a>		<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">],</span>
</span><span id="TypeParser-75"><a href="#TypeParser-75"><span class="linenos">  75</span></a>		<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">],</span>
</span><span id="TypeParser-76"><a href="#TypeParser-76"><span class="linenos">  76</span></a>		<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser-77"><a href="#TypeParser-77"><span class="linenos">  77</span></a>		<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser-78"><a href="#TypeParser-78"><span class="linenos">  78</span></a>		<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
</span><span id="TypeParser-79"><a href="#TypeParser-79"><span class="linenos">  79</span></a>		<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
</span><span id="TypeParser-80"><a href="#TypeParser-80"><span class="linenos">  80</span></a>		<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser-81"><a href="#TypeParser-81"><span class="linenos">  81</span></a>		<span class="n">case_sensitive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span><span id="TypeParser-82"><a href="#TypeParser-82"><span class="linenos">  82</span></a>	<span class="p">):</span>
</span><span id="TypeParser-83"><a href="#TypeParser-83"><span class="linenos">  83</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-84"><a href="#TypeParser-84"><span class="linenos">  84</span></a><span class="sd">			Initialise a new parser</span>
</span><span id="TypeParser-85"><a href="#TypeParser-85"><span class="linenos">  85</span></a>
</span><span id="TypeParser-86"><a href="#TypeParser-86"><span class="linenos">  86</span></a><span class="sd">			The behaviour of the parser and the type inference can be configured either in the constructor or using mutable properties of a parser instance. For example,</span>
</span><span id="TypeParser-87"><a href="#TypeParser-87"><span class="linenos">  87</span></a>
</span><span id="TypeParser-88"><a href="#TypeParser-88"><span class="linenos">  88</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-89"><a href="#TypeParser-89"><span class="linenos">  89</span></a><span class="sd">			parser = TypeParser(list_delimiter=&quot;,&quot;)</span>
</span><span id="TypeParser-90"><a href="#TypeParser-90"><span class="linenos">  90</span></a><span class="sd">			assert parser.list_delimiter == &quot;,&quot;</span>
</span><span id="TypeParser-91"><a href="#TypeParser-91"><span class="linenos">  91</span></a><span class="sd">			parser.list_delimiter = &quot;;&quot;</span>
</span><span id="TypeParser-92"><a href="#TypeParser-92"><span class="linenos">  92</span></a><span class="sd">			assert parser.list_delimiter == &quot;;&quot;</span>
</span><span id="TypeParser-93"><a href="#TypeParser-93"><span class="linenos">  93</span></a><span class="sd">			```</span>
</span><span id="TypeParser-94"><a href="#TypeParser-94"><span class="linenos">  94</span></a>
</span><span id="TypeParser-95"><a href="#TypeParser-95"><span class="linenos">  95</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser-96"><a href="#TypeParser-96"><span class="linenos">  96</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser-97"><a href="#TypeParser-97"><span class="linenos">  97</span></a><span class="sd">			`trim`</span>
</span><span id="TypeParser-98"><a href="#TypeParser-98"><span class="linenos">  98</span></a><span class="sd">			: whether leading and trailing whitespace should be stripped from strings</span>
</span><span id="TypeParser-99"><a href="#TypeParser-99"><span class="linenos">  99</span></a>
</span><span id="TypeParser-100"><a href="#TypeParser-100"><span class="linenos"> 100</span></a><span class="sd">			`use_decimal`</span>
</span><span id="TypeParser-101"><a href="#TypeParser-101"><span class="linenos"> 101</span></a><span class="sd">			: whether non-integer numeric values should be inferred to be Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer the type (`infer()` `infer_series()`, `infer_table()`), and does not affect methods where the type is explicitly specified (`is_float()`, `is_decimal()`, `parse_float()`, `parse_decimal()`).</span>
</span><span id="TypeParser-102"><a href="#TypeParser-102"><span class="linenos"> 102</span></a>
</span><span id="TypeParser-103"><a href="#TypeParser-103"><span class="linenos"> 103</span></a><span class="sd">			`list_delimiter`</span>
</span><span id="TypeParser-104"><a href="#TypeParser-104"><span class="linenos"> 104</span></a><span class="sd">			: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead. Note that this setting is unaffected by &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.trim&lt;/code&gt; and &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.case_sensitive&lt;/code&gt;, and will always be used verbatim.</span>
</span><span id="TypeParser-105"><a href="#TypeParser-105"><span class="linenos"> 105</span></a>
</span><span id="TypeParser-106"><a href="#TypeParser-106"><span class="linenos"> 106</span></a><span class="sd">			`none_values`</span>
</span><span id="TypeParser-107"><a href="#TypeParser-107"><span class="linenos"> 107</span></a><span class="sd">			: list of strings that represent the value `None`</span>
</span><span id="TypeParser-108"><a href="#TypeParser-108"><span class="linenos"> 108</span></a>
</span><span id="TypeParser-109"><a href="#TypeParser-109"><span class="linenos"> 109</span></a><span class="sd">			`none_case_sensitive`</span>
</span><span id="TypeParser-110"><a href="#TypeParser-110"><span class="linenos"> 110</span></a><span class="sd">			: whether matches against `none_values` should be made in a case-sensitive manner</span>
</span><span id="TypeParser-111"><a href="#TypeParser-111"><span class="linenos"> 111</span></a>
</span><span id="TypeParser-112"><a href="#TypeParser-112"><span class="linenos"> 112</span></a><span class="sd">			`true_values`</span>
</span><span id="TypeParser-113"><a href="#TypeParser-113"><span class="linenos"> 113</span></a><span class="sd">			: list of strings that represent the bool value `True`</span>
</span><span id="TypeParser-114"><a href="#TypeParser-114"><span class="linenos"> 114</span></a>
</span><span id="TypeParser-115"><a href="#TypeParser-115"><span class="linenos"> 115</span></a><span class="sd">			`false_values`</span>
</span><span id="TypeParser-116"><a href="#TypeParser-116"><span class="linenos"> 116</span></a><span class="sd">			: list of strings that represent the bool value `False`</span>
</span><span id="TypeParser-117"><a href="#TypeParser-117"><span class="linenos"> 117</span></a>
</span><span id="TypeParser-118"><a href="#TypeParser-118"><span class="linenos"> 118</span></a><span class="sd">			`bool_case_sensitive`</span>
</span><span id="TypeParser-119"><a href="#TypeParser-119"><span class="linenos"> 119</span></a><span class="sd">			: whether matches against `true_values` and `false_values` should be made in a case-sensitive manner</span>
</span><span id="TypeParser-120"><a href="#TypeParser-120"><span class="linenos"> 120</span></a>
</span><span id="TypeParser-121"><a href="#TypeParser-121"><span class="linenos"> 121</span></a><span class="sd">			`int_case_sensitive`</span>
</span><span id="TypeParser-122"><a href="#TypeParser-122"><span class="linenos"> 122</span></a><span class="sd">			: whether checks for int should be done in a case-sensitive manner. This only applies to values given in scientific notation, where the mantissa and exponent usually are separated by `e`.</span>
</span><span id="TypeParser-123"><a href="#TypeParser-123"><span class="linenos"> 123</span></a>
</span><span id="TypeParser-124"><a href="#TypeParser-124"><span class="linenos"> 124</span></a><span class="sd">			`inf_values`</span>
</span><span id="TypeParser-125"><a href="#TypeParser-125"><span class="linenos"> 125</span></a><span class="sd">			: list of strings that represent the float or Decimal value of infinity. Each of the strings can also be prepended with a negative sign to represent negative infinity.</span>
</span><span id="TypeParser-126"><a href="#TypeParser-126"><span class="linenos"> 126</span></a>
</span><span id="TypeParser-127"><a href="#TypeParser-127"><span class="linenos"> 127</span></a><span class="sd">			`nan_values`</span>
</span><span id="TypeParser-128"><a href="#TypeParser-128"><span class="linenos"> 128</span></a><span class="sd">			: list of strings that represent a float or Decimal that is NaN (not a number)</span>
</span><span id="TypeParser-129"><a href="#TypeParser-129"><span class="linenos"> 129</span></a>
</span><span id="TypeParser-130"><a href="#TypeParser-130"><span class="linenos"> 130</span></a><span class="sd">			`float_case_sensitive`</span>
</span><span id="TypeParser-131"><a href="#TypeParser-131"><span class="linenos"> 131</span></a><span class="sd">			: whether checks for float or Decimal should be done in a case-sensitive manner. This applies to matches against `inf_values` and `nan_values`, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by `e`.</span>
</span><span id="TypeParser-132"><a href="#TypeParser-132"><span class="linenos"> 132</span></a>
</span><span id="TypeParser-133"><a href="#TypeParser-133"><span class="linenos"> 133</span></a><span class="sd">			`case_sensitive`</span>
</span><span id="TypeParser-134"><a href="#TypeParser-134"><span class="linenos"> 134</span></a><span class="sd">			: whether all matches should be made in a case-sensitive manner. Sets all of `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`, `float_case_sensitive` to the same value, discarding any individual settings.</span>
</span><span id="TypeParser-135"><a href="#TypeParser-135"><span class="linenos"> 135</span></a>
</span><span id="TypeParser-136"><a href="#TypeParser-136"><span class="linenos"> 136</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-137"><a href="#TypeParser-137"><span class="linenos"> 137</span></a><span class="sd">			------</span>
</span><span id="TypeParser-138"><a href="#TypeParser-138"><span class="linenos"> 138</span></a><span class="sd">			`ValueError` if any of the options would lead to ambiguities during parsing</span>
</span><span id="TypeParser-139"><a href="#TypeParser-139"><span class="linenos"> 139</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-140"><a href="#TypeParser-140"><span class="linenos"> 140</span></a>
</span><span id="TypeParser-141"><a href="#TypeParser-141"><span class="linenos"> 141</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-142"><a href="#TypeParser-142"><span class="linenos"> 142</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-143"><a href="#TypeParser-143"><span class="linenos"> 143</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="TypeParser-144"><a href="#TypeParser-144"><span class="linenos"> 144</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-145"><a href="#TypeParser-145"><span class="linenos"> 145</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-146"><a href="#TypeParser-146"><span class="linenos"> 146</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-147"><a href="#TypeParser-147"><span class="linenos"> 147</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-148"><a href="#TypeParser-148"><span class="linenos"> 148</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-149"><a href="#TypeParser-149"><span class="linenos"> 149</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-150"><a href="#TypeParser-150"><span class="linenos"> 150</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-151"><a href="#TypeParser-151"><span class="linenos"> 151</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-152"><a href="#TypeParser-152"><span class="linenos"> 152</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-153"><a href="#TypeParser-153"><span class="linenos"> 153</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-154"><a href="#TypeParser-154"><span class="linenos"> 154</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-155"><a href="#TypeParser-155"><span class="linenos"> 155</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-156"><a href="#TypeParser-156"><span class="linenos"> 156</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser-157"><a href="#TypeParser-157"><span class="linenos"> 157</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-158"><a href="#TypeParser-158"><span class="linenos"> 158</span></a>
</span><span id="TypeParser-159"><a href="#TypeParser-159"><span class="linenos"> 159</span></a>		<span class="c1"># Unconfigurable default values</span>
</span><span id="TypeParser-160"><a href="#TypeParser-160"><span class="linenos"> 160</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
</span><span id="TypeParser-161"><a href="#TypeParser-161"><span class="linenos"> 161</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">,</span> <span class="s2">&quot;−&quot;</span><span class="p">}</span>
</span><span id="TypeParser-162"><a href="#TypeParser-162"><span class="linenos"> 162</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">}</span>
</span><span id="TypeParser-163"><a href="#TypeParser-163"><span class="linenos"> 163</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">}</span>  <span class="c1"># Because isdigit(&quot;²&quot;) == True, but int(&quot;²&quot;) is invalid</span>
</span><span id="TypeParser-164"><a href="#TypeParser-164"><span class="linenos"> 164</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_&quot;</span><span class="p">}</span>
</span><span id="TypeParser-165"><a href="#TypeParser-165"><span class="linenos"> 165</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
</span><span id="TypeParser-166"><a href="#TypeParser-166"><span class="linenos"> 166</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
</span><span id="TypeParser-167"><a href="#TypeParser-167"><span class="linenos"> 167</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">}</span>
</span><span id="TypeParser-168"><a href="#TypeParser-168"><span class="linenos"> 168</span></a>		<span class="c1"># special_chars = self._reserved_chars | self._list_delimiter</span>
</span><span id="TypeParser-169"><a href="#TypeParser-169"><span class="linenos"> 169</span></a>
</span><span id="TypeParser-170"><a href="#TypeParser-170"><span class="linenos"> 170</span></a>		<span class="c1"># Configured values</span>
</span><span id="TypeParser-171"><a href="#TypeParser-171"><span class="linenos"> 171</span></a>
</span><span id="TypeParser-172"><a href="#TypeParser-172"><span class="linenos"> 172</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span>
</span><span id="TypeParser-173"><a href="#TypeParser-173"><span class="linenos"> 173</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span> <span class="o">=</span> <span class="n">use_decimal</span>
</span><span id="TypeParser-174"><a href="#TypeParser-174"><span class="linenos"> 174</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="n">list_delimiter</span>
</span><span id="TypeParser-175"><a href="#TypeParser-175"><span class="linenos"> 175</span></a>
</span><span id="TypeParser-176"><a href="#TypeParser-176"><span class="linenos"> 176</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">none_case_sensitive</span>
</span><span id="TypeParser-177"><a href="#TypeParser-177"><span class="linenos"> 177</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">bool_case_sensitive</span>
</span><span id="TypeParser-178"><a href="#TypeParser-178"><span class="linenos"> 178</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">int_case_sensitive</span>
</span><span id="TypeParser-179"><a href="#TypeParser-179"><span class="linenos"> 179</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">float_case_sensitive</span>
</span><span id="TypeParser-180"><a href="#TypeParser-180"><span class="linenos"> 180</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
</span><span id="TypeParser-181"><a href="#TypeParser-181"><span class="linenos"> 181</span></a>
</span><span id="TypeParser-182"><a href="#TypeParser-182"><span class="linenos"> 182</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="n">none_values</span>
</span><span id="TypeParser-183"><a href="#TypeParser-183"><span class="linenos"> 183</span></a>
</span><span id="TypeParser-184"><a href="#TypeParser-184"><span class="linenos"> 184</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="n">true_values</span>
</span><span id="TypeParser-185"><a href="#TypeParser-185"><span class="linenos"> 185</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="n">false_values</span>
</span><span id="TypeParser-186"><a href="#TypeParser-186"><span class="linenos"> 186</span></a>
</span><span id="TypeParser-187"><a href="#TypeParser-187"><span class="linenos"> 187</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="n">inf_values</span>
</span><span id="TypeParser-188"><a href="#TypeParser-188"><span class="linenos"> 188</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="n">nan_values</span>
</span><span id="TypeParser-189"><a href="#TypeParser-189"><span class="linenos"> 189</span></a>
</span><span id="TypeParser-190"><a href="#TypeParser-190"><span class="linenos"> 190</span></a>		<span class="c1"># Check if any special values conflict</span>
</span><span id="TypeParser-191"><a href="#TypeParser-191"><span class="linenos"> 191</span></a>		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">special_values</span> <span class="ow">in</span> <span class="p">[</span>
</span><span id="TypeParser-192"><a href="#TypeParser-192"><span class="linenos"> 192</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]),</span>
</span><span id="TypeParser-193"><a href="#TypeParser-193"><span class="linenos"> 193</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span><span class="p">),</span>
</span><span id="TypeParser-194"><a href="#TypeParser-194"><span class="linenos"> 194</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">),</span>
</span><span id="TypeParser-195"><a href="#TypeParser-195"><span class="linenos"> 195</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">),</span>
</span><span id="TypeParser-196"><a href="#TypeParser-196"><span class="linenos"> 196</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">),</span>
</span><span id="TypeParser-197"><a href="#TypeParser-197"><span class="linenos"> 197</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">),</span>
</span><span id="TypeParser-198"><a href="#TypeParser-198"><span class="linenos"> 198</span></a>		<span class="p">]:</span>
</span><span id="TypeParser-199"><a href="#TypeParser-199"><span class="linenos"> 199</span></a>			<span class="k">for</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="n">special_values</span><span class="p">:</span>
</span><span id="TypeParser-200"><a href="#TypeParser-200"><span class="linenos"> 200</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">_validate_special</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">special_value</span><span class="p">)</span>
</span><span id="TypeParser-201"><a href="#TypeParser-201"><span class="linenos"> 201</span></a>
</span><span id="TypeParser-202"><a href="#TypeParser-202"><span class="linenos"> 202</span></a>
</span><span id="TypeParser-203"><a href="#TypeParser-203"><span class="linenos"> 203</span></a>	<span class="k">def</span> <span class="nf">_validate_special</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">_SpecialValue</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
</span><span id="TypeParser-204"><a href="#TypeParser-204"><span class="linenos"> 204</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span><span class="p">:</span>
</span><span id="TypeParser-205"><a href="#TypeParser-205"><span class="linenos"> 205</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use reserved char as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-206"><a href="#TypeParser-206"><span class="linenos"> 206</span></a>
</span><span id="TypeParser-207"><a href="#TypeParser-207"><span class="linenos"> 207</span></a>		<span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-208"><a href="#TypeParser-208"><span class="linenos"> 208</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use None value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-209"><a href="#TypeParser-209"><span class="linenos"> 209</span></a>
</span><span id="TypeParser-210"><a href="#TypeParser-210"><span class="linenos"> 210</span></a>		<span class="k">if</span> <span class="p">(</span>
</span><span id="TypeParser-211"><a href="#TypeParser-211"><span class="linenos"> 211</span></a>			<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">or</span>
</span><span id="TypeParser-212"><a href="#TypeParser-212"><span class="linenos"> 212</span></a>			<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
</span><span id="TypeParser-213"><a href="#TypeParser-213"><span class="linenos"> 213</span></a>			<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser-214"><a href="#TypeParser-214"><span class="linenos"> 214</span></a>		<span class="p">):</span>
</span><span id="TypeParser-215"><a href="#TypeParser-215"><span class="linenos"> 215</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use bool value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-216"><a href="#TypeParser-216"><span class="linenos"> 216</span></a>
</span><span id="TypeParser-217"><a href="#TypeParser-217"><span class="linenos"> 217</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-218"><a href="#TypeParser-218"><span class="linenos"> 218</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use int value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-219"><a href="#TypeParser-219"><span class="linenos"> 219</span></a>
</span><span id="TypeParser-220"><a href="#TypeParser-220"><span class="linenos"> 220</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span><span class="p">:</span>
</span><span id="TypeParser-221"><a href="#TypeParser-221"><span class="linenos"> 221</span></a>			<span class="k">if</span> <span class="p">(</span>
</span><span id="TypeParser-222"><a href="#TypeParser-222"><span class="linenos"> 222</span></a>				<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="ow">or</span>
</span><span id="TypeParser-223"><a href="#TypeParser-223"><span class="linenos"> 223</span></a>				<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">is_nan</span><span class="p">())</span> <span class="ow">or</span>
</span><span id="TypeParser-224"><a href="#TypeParser-224"><span class="linenos"> 224</span></a>				<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser-225"><a href="#TypeParser-225"><span class="linenos"> 225</span></a>			<span class="p">):</span>
</span><span id="TypeParser-226"><a href="#TypeParser-226"><span class="linenos"> 226</span></a>				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use Decimal value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-227"><a href="#TypeParser-227"><span class="linenos"> 227</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-228"><a href="#TypeParser-228"><span class="linenos"> 228</span></a>			<span class="k">if</span> <span class="p">(</span>
</span><span id="TypeParser-229"><a href="#TypeParser-229"><span class="linenos"> 229</span></a>				<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="ow">or</span>
</span><span id="TypeParser-230"><a href="#TypeParser-230"><span class="linenos"> 230</span></a>				<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="ow">or</span>
</span><span id="TypeParser-231"><a href="#TypeParser-231"><span class="linenos"> 231</span></a>				<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser-232"><a href="#TypeParser-232"><span class="linenos"> 232</span></a>			<span class="p">):</span>
</span><span id="TypeParser-233"><a href="#TypeParser-233"><span class="linenos"> 233</span></a>				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use float value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-234"><a href="#TypeParser-234"><span class="linenos"> 234</span></a>
</span><span id="TypeParser-235"><a href="#TypeParser-235"><span class="linenos"> 235</span></a>
</span><span id="TypeParser-236"><a href="#TypeParser-236"><span class="linenos"> 236</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-237"><a href="#TypeParser-237"><span class="linenos"> 237</span></a>	<span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-238"><a href="#TypeParser-238"><span class="linenos"> 238</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span>
</span><span id="TypeParser-239"><a href="#TypeParser-239"><span class="linenos"> 239</span></a>
</span><span id="TypeParser-240"><a href="#TypeParser-240"><span class="linenos"> 240</span></a>	<span class="nd">@trim</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-241"><a href="#TypeParser-241"><span class="linenos"> 241</span></a>	<span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
</span><span id="TypeParser-242"><a href="#TypeParser-242"><span class="linenos"> 242</span></a>		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-243"><a href="#TypeParser-243"><span class="linenos"> 243</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;trim must be a bool: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-244"><a href="#TypeParser-244"><span class="linenos"> 244</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-245"><a href="#TypeParser-245"><span class="linenos"> 245</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_trim</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-246"><a href="#TypeParser-246"><span class="linenos"> 246</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span>
</span><span id="TypeParser-247"><a href="#TypeParser-247"><span class="linenos"> 247</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span>
</span><span id="TypeParser-248"><a href="#TypeParser-248"><span class="linenos"> 248</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span>
</span><span id="TypeParser-249"><a href="#TypeParser-249"><span class="linenos"> 249</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span>
</span><span id="TypeParser-250"><a href="#TypeParser-250"><span class="linenos"> 250</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span>
</span><span id="TypeParser-251"><a href="#TypeParser-251"><span class="linenos"> 251</span></a>
</span><span id="TypeParser-252"><a href="#TypeParser-252"><span class="linenos"> 252</span></a>
</span><span id="TypeParser-253"><a href="#TypeParser-253"><span class="linenos"> 253</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-254"><a href="#TypeParser-254"><span class="linenos"> 254</span></a>	<span class="k">def</span> <span class="nf">use_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-255"><a href="#TypeParser-255"><span class="linenos"> 255</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span>
</span><span id="TypeParser-256"><a href="#TypeParser-256"><span class="linenos"> 256</span></a>
</span><span id="TypeParser-257"><a href="#TypeParser-257"><span class="linenos"> 257</span></a>	<span class="nd">@use_decimal</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-258"><a href="#TypeParser-258"><span class="linenos"> 258</span></a>	<span class="k">def</span> <span class="nf">use_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
</span><span id="TypeParser-259"><a href="#TypeParser-259"><span class="linenos"> 259</span></a>		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-260"><a href="#TypeParser-260"><span class="linenos"> 260</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;use_decimal must be a bool: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-261"><a href="#TypeParser-261"><span class="linenos"> 261</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-262"><a href="#TypeParser-262"><span class="linenos"> 262</span></a>
</span><span id="TypeParser-263"><a href="#TypeParser-263"><span class="linenos"> 263</span></a>
</span><span id="TypeParser-264"><a href="#TypeParser-264"><span class="linenos"> 264</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-265"><a href="#TypeParser-265"><span class="linenos"> 265</span></a>	<span class="k">def</span> <span class="nf">list_delimiter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
</span><span id="TypeParser-266"><a href="#TypeParser-266"><span class="linenos"> 266</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span>
</span><span id="TypeParser-267"><a href="#TypeParser-267"><span class="linenos"> 267</span></a>
</span><span id="TypeParser-268"><a href="#TypeParser-268"><span class="linenos"> 268</span></a>	<span class="nd">@list_delimiter</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-269"><a href="#TypeParser-269"><span class="linenos"> 269</span></a>	<span class="k">def</span> <span class="nf">list_delimiter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
</span><span id="TypeParser-270"><a href="#TypeParser-270"><span class="linenos"> 270</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-271"><a href="#TypeParser-271"><span class="linenos"> 271</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;list_delimiter must be a str or None: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-272"><a href="#TypeParser-272"><span class="linenos"> 272</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-273"><a href="#TypeParser-273"><span class="linenos"> 273</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_validate_special</span><span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-274"><a href="#TypeParser-274"><span class="linenos"> 274</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-275"><a href="#TypeParser-275"><span class="linenos"> 275</span></a>
</span><span id="TypeParser-276"><a href="#TypeParser-276"><span class="linenos"> 276</span></a>
</span><span id="TypeParser-277"><a href="#TypeParser-277"><span class="linenos"> 277</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-278"><a href="#TypeParser-278"><span class="linenos"> 278</span></a>	<span class="k">def</span> <span class="nf">none_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
</span><span id="TypeParser-279"><a href="#TypeParser-279"><span class="linenos"> 279</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-280"><a href="#TypeParser-280"><span class="linenos"> 280</span></a>			<span class="k">return</span> <span class="p">{</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span><span class="p">}</span>
</span><span id="TypeParser-281"><a href="#TypeParser-281"><span class="linenos"> 281</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-282"><a href="#TypeParser-282"><span class="linenos"> 282</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span>
</span><span id="TypeParser-283"><a href="#TypeParser-283"><span class="linenos"> 283</span></a>
</span><span id="TypeParser-284"><a href="#TypeParser-284"><span class="linenos"> 284</span></a>	<span class="nd">@none_values</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-285"><a href="#TypeParser-285"><span class="linenos"> 285</span></a>	<span class="k">def</span> <span class="nf">none_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
</span><span id="TypeParser-286"><a href="#TypeParser-286"><span class="linenos"> 286</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
</span><span id="TypeParser-287"><a href="#TypeParser-287"><span class="linenos"> 287</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;none_values must be an Iterable: </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-288"><a href="#TypeParser-288"><span class="linenos"> 288</span></a>		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
</span><span id="TypeParser-289"><a href="#TypeParser-289"><span class="linenos"> 289</span></a>			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-290"><a href="#TypeParser-290"><span class="linenos"> 290</span></a>				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;each item in none_values must be a str: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-291"><a href="#TypeParser-291"><span class="linenos"> 291</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-292"><a href="#TypeParser-292"><span class="linenos"> 292</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-293"><a href="#TypeParser-293"><span class="linenos"> 293</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-294"><a href="#TypeParser-294"><span class="linenos"> 294</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-295"><a href="#TypeParser-295"><span class="linenos"> 295</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-296"><a href="#TypeParser-296"><span class="linenos"> 296</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-297"><a href="#TypeParser-297"><span class="linenos"> 297</span></a>
</span><span id="TypeParser-298"><a href="#TypeParser-298"><span class="linenos"> 298</span></a>
</span><span id="TypeParser-299"><a href="#TypeParser-299"><span class="linenos"> 299</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-300"><a href="#TypeParser-300"><span class="linenos"> 300</span></a>	<span class="k">def</span> <span class="nf">none_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-301"><a href="#TypeParser-301"><span class="linenos"> 301</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span>
</span><span id="TypeParser-302"><a href="#TypeParser-302"><span class="linenos"> 302</span></a>
</span><span id="TypeParser-303"><a href="#TypeParser-303"><span class="linenos"> 303</span></a>	<span class="nd">@none_case_sensitive</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-304"><a href="#TypeParser-304"><span class="linenos"> 304</span></a>	<span class="k">def</span> <span class="nf">none_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
</span><span id="TypeParser-305"><a href="#TypeParser-305"><span class="linenos"> 305</span></a>		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-306"><a href="#TypeParser-306"><span class="linenos"> 306</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;none_case_sensitive must be a bool: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-307"><a href="#TypeParser-307"><span class="linenos"> 307</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-308"><a href="#TypeParser-308"><span class="linenos"> 308</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-309"><a href="#TypeParser-309"><span class="linenos"> 309</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span>
</span><span id="TypeParser-310"><a href="#TypeParser-310"><span class="linenos"> 310</span></a>
</span><span id="TypeParser-311"><a href="#TypeParser-311"><span class="linenos"> 311</span></a>
</span><span id="TypeParser-312"><a href="#TypeParser-312"><span class="linenos"> 312</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-313"><a href="#TypeParser-313"><span class="linenos"> 313</span></a>	<span class="k">def</span> <span class="nf">true_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
</span><span id="TypeParser-314"><a href="#TypeParser-314"><span class="linenos"> 314</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-315"><a href="#TypeParser-315"><span class="linenos"> 315</span></a>			<span class="k">return</span> <span class="p">{</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span><span class="p">}</span>
</span><span id="TypeParser-316"><a href="#TypeParser-316"><span class="linenos"> 316</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-317"><a href="#TypeParser-317"><span class="linenos"> 317</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span>
</span><span id="TypeParser-318"><a href="#TypeParser-318"><span class="linenos"> 318</span></a>
</span><span id="TypeParser-319"><a href="#TypeParser-319"><span class="linenos"> 319</span></a>	<span class="nd">@true_values</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-320"><a href="#TypeParser-320"><span class="linenos"> 320</span></a>	<span class="k">def</span> <span class="nf">true_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
</span><span id="TypeParser-321"><a href="#TypeParser-321"><span class="linenos"> 321</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
</span><span id="TypeParser-322"><a href="#TypeParser-322"><span class="linenos"> 322</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;true_values must be an Iterable: </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-323"><a href="#TypeParser-323"><span class="linenos"> 323</span></a>		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
</span><span id="TypeParser-324"><a href="#TypeParser-324"><span class="linenos"> 324</span></a>			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-325"><a href="#TypeParser-325"><span class="linenos"> 325</span></a>				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;each item in true_values must be a str: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-326"><a href="#TypeParser-326"><span class="linenos"> 326</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-327"><a href="#TypeParser-327"><span class="linenos"> 327</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-328"><a href="#TypeParser-328"><span class="linenos"> 328</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-329"><a href="#TypeParser-329"><span class="linenos"> 329</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-330"><a href="#TypeParser-330"><span class="linenos"> 330</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-331"><a href="#TypeParser-331"><span class="linenos"> 331</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-332"><a href="#TypeParser-332"><span class="linenos"> 332</span></a>
</span><span id="TypeParser-333"><a href="#TypeParser-333"><span class="linenos"> 333</span></a>
</span><span id="TypeParser-334"><a href="#TypeParser-334"><span class="linenos"> 334</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-335"><a href="#TypeParser-335"><span class="linenos"> 335</span></a>	<span class="k">def</span> <span class="nf">false_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
</span><span id="TypeParser-336"><a href="#TypeParser-336"><span class="linenos"> 336</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-337"><a href="#TypeParser-337"><span class="linenos"> 337</span></a>			<span class="k">return</span> <span class="p">{</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span><span class="p">}</span>
</span><span id="TypeParser-338"><a href="#TypeParser-338"><span class="linenos"> 338</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-339"><a href="#TypeParser-339"><span class="linenos"> 339</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span>
</span><span id="TypeParser-340"><a href="#TypeParser-340"><span class="linenos"> 340</span></a>
</span><span id="TypeParser-341"><a href="#TypeParser-341"><span class="linenos"> 341</span></a>	<span class="nd">@false_values</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-342"><a href="#TypeParser-342"><span class="linenos"> 342</span></a>	<span class="k">def</span> <span class="nf">false_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
</span><span id="TypeParser-343"><a href="#TypeParser-343"><span class="linenos"> 343</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
</span><span id="TypeParser-344"><a href="#TypeParser-344"><span class="linenos"> 344</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;false_values must be an Iterable: </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-345"><a href="#TypeParser-345"><span class="linenos"> 345</span></a>		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
</span><span id="TypeParser-346"><a href="#TypeParser-346"><span class="linenos"> 346</span></a>			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-347"><a href="#TypeParser-347"><span class="linenos"> 347</span></a>				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;each item in false_values must be a str: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-348"><a href="#TypeParser-348"><span class="linenos"> 348</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-349"><a href="#TypeParser-349"><span class="linenos"> 349</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-350"><a href="#TypeParser-350"><span class="linenos"> 350</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-351"><a href="#TypeParser-351"><span class="linenos"> 351</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-352"><a href="#TypeParser-352"><span class="linenos"> 352</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-353"><a href="#TypeParser-353"><span class="linenos"> 353</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-354"><a href="#TypeParser-354"><span class="linenos"> 354</span></a>
</span><span id="TypeParser-355"><a href="#TypeParser-355"><span class="linenos"> 355</span></a>
</span><span id="TypeParser-356"><a href="#TypeParser-356"><span class="linenos"> 356</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-357"><a href="#TypeParser-357"><span class="linenos"> 357</span></a>	<span class="k">def</span> <span class="nf">bool_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-358"><a href="#TypeParser-358"><span class="linenos"> 358</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span>
</span><span id="TypeParser-359"><a href="#TypeParser-359"><span class="linenos"> 359</span></a>
</span><span id="TypeParser-360"><a href="#TypeParser-360"><span class="linenos"> 360</span></a>	<span class="nd">@bool_case_sensitive</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-361"><a href="#TypeParser-361"><span class="linenos"> 361</span></a>	<span class="k">def</span> <span class="nf">bool_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
</span><span id="TypeParser-362"><a href="#TypeParser-362"><span class="linenos"> 362</span></a>		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-363"><a href="#TypeParser-363"><span class="linenos"> 363</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bool_case_sensitive must be a bool: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-364"><a href="#TypeParser-364"><span class="linenos"> 364</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-365"><a href="#TypeParser-365"><span class="linenos"> 365</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-366"><a href="#TypeParser-366"><span class="linenos"> 366</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span>
</span><span id="TypeParser-367"><a href="#TypeParser-367"><span class="linenos"> 367</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span>
</span><span id="TypeParser-368"><a href="#TypeParser-368"><span class="linenos"> 368</span></a>
</span><span id="TypeParser-369"><a href="#TypeParser-369"><span class="linenos"> 369</span></a>
</span><span id="TypeParser-370"><a href="#TypeParser-370"><span class="linenos"> 370</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-371"><a href="#TypeParser-371"><span class="linenos"> 371</span></a>	<span class="k">def</span> <span class="nf">int_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-372"><a href="#TypeParser-372"><span class="linenos"> 372</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span>
</span><span id="TypeParser-373"><a href="#TypeParser-373"><span class="linenos"> 373</span></a>
</span><span id="TypeParser-374"><a href="#TypeParser-374"><span class="linenos"> 374</span></a>	<span class="nd">@int_case_sensitive</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-375"><a href="#TypeParser-375"><span class="linenos"> 375</span></a>	<span class="k">def</span> <span class="nf">int_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
</span><span id="TypeParser-376"><a href="#TypeParser-376"><span class="linenos"> 376</span></a>		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-377"><a href="#TypeParser-377"><span class="linenos"> 377</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;int_case_sensitive must be a bool: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-378"><a href="#TypeParser-378"><span class="linenos"> 378</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-379"><a href="#TypeParser-379"><span class="linenos"> 379</span></a>
</span><span id="TypeParser-380"><a href="#TypeParser-380"><span class="linenos"> 380</span></a>
</span><span id="TypeParser-381"><a href="#TypeParser-381"><span class="linenos"> 381</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-382"><a href="#TypeParser-382"><span class="linenos"> 382</span></a>	<span class="k">def</span> <span class="nf">inf_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
</span><span id="TypeParser-383"><a href="#TypeParser-383"><span class="linenos"> 383</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-384"><a href="#TypeParser-384"><span class="linenos"> 384</span></a>			<span class="k">return</span> <span class="p">{</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span><span class="p">}</span>
</span><span id="TypeParser-385"><a href="#TypeParser-385"><span class="linenos"> 385</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-386"><a href="#TypeParser-386"><span class="linenos"> 386</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span>
</span><span id="TypeParser-387"><a href="#TypeParser-387"><span class="linenos"> 387</span></a>
</span><span id="TypeParser-388"><a href="#TypeParser-388"><span class="linenos"> 388</span></a>	<span class="nd">@inf_values</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-389"><a href="#TypeParser-389"><span class="linenos"> 389</span></a>	<span class="k">def</span> <span class="nf">inf_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
</span><span id="TypeParser-390"><a href="#TypeParser-390"><span class="linenos"> 390</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
</span><span id="TypeParser-391"><a href="#TypeParser-391"><span class="linenos"> 391</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inf_values must be an Iterable: </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-392"><a href="#TypeParser-392"><span class="linenos"> 392</span></a>		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
</span><span id="TypeParser-393"><a href="#TypeParser-393"><span class="linenos"> 393</span></a>			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-394"><a href="#TypeParser-394"><span class="linenos"> 394</span></a>				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;each item in inf_values must be a str: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-395"><a href="#TypeParser-395"><span class="linenos"> 395</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-396"><a href="#TypeParser-396"><span class="linenos"> 396</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-397"><a href="#TypeParser-397"><span class="linenos"> 397</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-398"><a href="#TypeParser-398"><span class="linenos"> 398</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-399"><a href="#TypeParser-399"><span class="linenos"> 399</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-400"><a href="#TypeParser-400"><span class="linenos"> 400</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-401"><a href="#TypeParser-401"><span class="linenos"> 401</span></a>
</span><span id="TypeParser-402"><a href="#TypeParser-402"><span class="linenos"> 402</span></a>
</span><span id="TypeParser-403"><a href="#TypeParser-403"><span class="linenos"> 403</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-404"><a href="#TypeParser-404"><span class="linenos"> 404</span></a>	<span class="k">def</span> <span class="nf">nan_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
</span><span id="TypeParser-405"><a href="#TypeParser-405"><span class="linenos"> 405</span></a>		<span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span>
</span><span id="TypeParser-406"><a href="#TypeParser-406"><span class="linenos"> 406</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-407"><a href="#TypeParser-407"><span class="linenos"> 407</span></a>			<span class="k">return</span> <span class="p">{</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span><span class="p">}</span>
</span><span id="TypeParser-408"><a href="#TypeParser-408"><span class="linenos"> 408</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-409"><a href="#TypeParser-409"><span class="linenos"> 409</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span>
</span><span id="TypeParser-410"><a href="#TypeParser-410"><span class="linenos"> 410</span></a>
</span><span id="TypeParser-411"><a href="#TypeParser-411"><span class="linenos"> 411</span></a>	<span class="nd">@nan_values</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-412"><a href="#TypeParser-412"><span class="linenos"> 412</span></a>	<span class="k">def</span> <span class="nf">nan_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
</span><span id="TypeParser-413"><a href="#TypeParser-413"><span class="linenos"> 413</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
</span><span id="TypeParser-414"><a href="#TypeParser-414"><span class="linenos"> 414</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nan_values must be an Iterable: </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-415"><a href="#TypeParser-415"><span class="linenos"> 415</span></a>		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
</span><span id="TypeParser-416"><a href="#TypeParser-416"><span class="linenos"> 416</span></a>			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-417"><a href="#TypeParser-417"><span class="linenos"> 417</span></a>				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;each item in nan_values must be a str: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-418"><a href="#TypeParser-418"><span class="linenos"> 418</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-419"><a href="#TypeParser-419"><span class="linenos"> 419</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-420"><a href="#TypeParser-420"><span class="linenos"> 420</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-421"><a href="#TypeParser-421"><span class="linenos"> 421</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-422"><a href="#TypeParser-422"><span class="linenos"> 422</span></a>			<span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-423"><a href="#TypeParser-423"><span class="linenos"> 423</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-424"><a href="#TypeParser-424"><span class="linenos"> 424</span></a>
</span><span id="TypeParser-425"><a href="#TypeParser-425"><span class="linenos"> 425</span></a>
</span><span id="TypeParser-426"><a href="#TypeParser-426"><span class="linenos"> 426</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-427"><a href="#TypeParser-427"><span class="linenos"> 427</span></a>	<span class="k">def</span> <span class="nf">float_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-428"><a href="#TypeParser-428"><span class="linenos"> 428</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span>
</span><span id="TypeParser-429"><a href="#TypeParser-429"><span class="linenos"> 429</span></a>
</span><span id="TypeParser-430"><a href="#TypeParser-430"><span class="linenos"> 430</span></a>	<span class="nd">@float_case_sensitive</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-431"><a href="#TypeParser-431"><span class="linenos"> 431</span></a>	<span class="k">def</span> <span class="nf">float_case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
</span><span id="TypeParser-432"><a href="#TypeParser-432"><span class="linenos"> 432</span></a>		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-433"><a href="#TypeParser-433"><span class="linenos"> 433</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;float_case_sensitive must be a bool: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-434"><a href="#TypeParser-434"><span class="linenos"> 434</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-435"><a href="#TypeParser-435"><span class="linenos"> 435</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-436"><a href="#TypeParser-436"><span class="linenos"> 436</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span>
</span><span id="TypeParser-437"><a href="#TypeParser-437"><span class="linenos"> 437</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span>
</span><span id="TypeParser-438"><a href="#TypeParser-438"><span class="linenos"> 438</span></a>
</span><span id="TypeParser-439"><a href="#TypeParser-439"><span class="linenos"> 439</span></a>
</span><span id="TypeParser-440"><a href="#TypeParser-440"><span class="linenos"> 440</span></a>	<span class="nd">@property</span>
</span><span id="TypeParser-441"><a href="#TypeParser-441"><span class="linenos"> 441</span></a>	<span class="k">def</span> <span class="nf">case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
</span><span id="TypeParser-442"><a href="#TypeParser-442"><span class="linenos"> 442</span></a>		<span class="k">if</span> <span class="p">(</span>
</span><span id="TypeParser-443"><a href="#TypeParser-443"><span class="linenos"> 443</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span> <span class="ow">and</span>
</span><span id="TypeParser-444"><a href="#TypeParser-444"><span class="linenos"> 444</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span> <span class="ow">and</span>
</span><span id="TypeParser-445"><a href="#TypeParser-445"><span class="linenos"> 445</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span>
</span><span id="TypeParser-446"><a href="#TypeParser-446"><span class="linenos"> 446</span></a>		<span class="p">):</span>
</span><span id="TypeParser-447"><a href="#TypeParser-447"><span class="linenos"> 447</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span>
</span><span id="TypeParser-448"><a href="#TypeParser-448"><span class="linenos"> 448</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-449"><a href="#TypeParser-449"><span class="linenos"> 449</span></a>			<span class="k">return</span> <span class="kc">None</span>
</span><span id="TypeParser-450"><a href="#TypeParser-450"><span class="linenos"> 450</span></a>
</span><span id="TypeParser-451"><a href="#TypeParser-451"><span class="linenos"> 451</span></a>	<span class="nd">@case_sensitive</span><span class="o">.</span><span class="n">setter</span>
</span><span id="TypeParser-452"><a href="#TypeParser-452"><span class="linenos"> 452</span></a>	<span class="k">def</span> <span class="nf">case_sensitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
</span><span id="TypeParser-453"><a href="#TypeParser-453"><span class="linenos"> 453</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-454"><a href="#TypeParser-454"><span class="linenos"> 454</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;case_sensitive must be a bool or None: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-455"><a href="#TypeParser-455"><span class="linenos"> 455</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-456"><a href="#TypeParser-456"><span class="linenos"> 456</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-457"><a href="#TypeParser-457"><span class="linenos"> 457</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-458"><a href="#TypeParser-458"><span class="linenos"> 458</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-459"><a href="#TypeParser-459"><span class="linenos"> 459</span></a>			<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-460"><a href="#TypeParser-460"><span class="linenos"> 460</span></a>
</span><span id="TypeParser-461"><a href="#TypeParser-461"><span class="linenos"> 461</span></a>
</span><span id="TypeParser-462"><a href="#TypeParser-462"><span class="linenos"> 462</span></a>	<span class="k">def</span> <span class="nf">is_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-463"><a href="#TypeParser-463"><span class="linenos"> 463</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-464"><a href="#TypeParser-464"><span class="linenos"> 464</span></a><span class="sd">			Check if a string represents the value None</span>
</span><span id="TypeParser-465"><a href="#TypeParser-465"><span class="linenos"> 465</span></a>
</span><span id="TypeParser-466"><a href="#TypeParser-466"><span class="linenos"> 466</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_values&lt;/code&gt; will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-467"><a href="#TypeParser-467"><span class="linenos"> 467</span></a>
</span><span id="TypeParser-468"><a href="#TypeParser-468"><span class="linenos"> 468</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-469"><a href="#TypeParser-469"><span class="linenos"> 469</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-470"><a href="#TypeParser-470"><span class="linenos"> 470</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-471"><a href="#TypeParser-471"><span class="linenos"> 471</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser-472"><a href="#TypeParser-472"><span class="linenos"> 472</span></a>
</span><span id="TypeParser-473"><a href="#TypeParser-473"><span class="linenos"> 473</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-474"><a href="#TypeParser-474"><span class="linenos"> 474</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-475"><a href="#TypeParser-475"><span class="linenos"> 475</span></a><span class="sd">			whether it is None</span>
</span><span id="TypeParser-476"><a href="#TypeParser-476"><span class="linenos"> 476</span></a>
</span><span id="TypeParser-477"><a href="#TypeParser-477"><span class="linenos"> 477</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-478"><a href="#TypeParser-478"><span class="linenos"> 478</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-479"><a href="#TypeParser-479"><span class="linenos"> 479</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-480"><a href="#TypeParser-480"><span class="linenos"> 480</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-481"><a href="#TypeParser-481"><span class="linenos"> 481</span></a><span class="sd">			parser.is_none(&quot;&quot;)     # True</span>
</span><span id="TypeParser-482"><a href="#TypeParser-482"><span class="linenos"> 482</span></a><span class="sd">			parser.is_none(&quot;abc&quot;)  # False</span>
</span><span id="TypeParser-483"><a href="#TypeParser-483"><span class="linenos"> 483</span></a><span class="sd">			```</span>
</span><span id="TypeParser-484"><a href="#TypeParser-484"><span class="linenos"> 484</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-485"><a href="#TypeParser-485"><span class="linenos"> 485</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-486"><a href="#TypeParser-486"><span class="linenos"> 486</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-487"><a href="#TypeParser-487"><span class="linenos"> 487</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-488"><a href="#TypeParser-488"><span class="linenos"> 488</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser-489"><a href="#TypeParser-489"><span class="linenos"> 489</span></a>
</span><span id="TypeParser-490"><a href="#TypeParser-490"><span class="linenos"> 490</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span><span class="p">:</span>
</span><span id="TypeParser-491"><a href="#TypeParser-491"><span class="linenos"> 491</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-492"><a href="#TypeParser-492"><span class="linenos"> 492</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-493"><a href="#TypeParser-493"><span class="linenos"> 493</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-494"><a href="#TypeParser-494"><span class="linenos"> 494</span></a>
</span><span id="TypeParser-495"><a href="#TypeParser-495"><span class="linenos"> 495</span></a>
</span><span id="TypeParser-496"><a href="#TypeParser-496"><span class="linenos"> 496</span></a>	<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-497"><a href="#TypeParser-497"><span class="linenos"> 497</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-498"><a href="#TypeParser-498"><span class="linenos"> 498</span></a><span class="sd">			Check if a string represents a bool</span>
</span><span id="TypeParser-499"><a href="#TypeParser-499"><span class="linenos"> 499</span></a>
</span><span id="TypeParser-500"><a href="#TypeParser-500"><span class="linenos"> 500</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.true_values&lt;/code&gt; and &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.false_values&lt;/code&gt; will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.bool_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-501"><a href="#TypeParser-501"><span class="linenos"> 501</span></a>
</span><span id="TypeParser-502"><a href="#TypeParser-502"><span class="linenos"> 502</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-503"><a href="#TypeParser-503"><span class="linenos"> 503</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-504"><a href="#TypeParser-504"><span class="linenos"> 504</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-505"><a href="#TypeParser-505"><span class="linenos"> 505</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser-506"><a href="#TypeParser-506"><span class="linenos"> 506</span></a>
</span><span id="TypeParser-507"><a href="#TypeParser-507"><span class="linenos"> 507</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-508"><a href="#TypeParser-508"><span class="linenos"> 508</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-509"><a href="#TypeParser-509"><span class="linenos"> 509</span></a><span class="sd">			whether it is a bool</span>
</span><span id="TypeParser-510"><a href="#TypeParser-510"><span class="linenos"> 510</span></a>
</span><span id="TypeParser-511"><a href="#TypeParser-511"><span class="linenos"> 511</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-512"><a href="#TypeParser-512"><span class="linenos"> 512</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-513"><a href="#TypeParser-513"><span class="linenos"> 513</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-514"><a href="#TypeParser-514"><span class="linenos"> 514</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-515"><a href="#TypeParser-515"><span class="linenos"> 515</span></a><span class="sd">			parser.is_bool(&quot;true&quot;)  # True</span>
</span><span id="TypeParser-516"><a href="#TypeParser-516"><span class="linenos"> 516</span></a><span class="sd">			parser.is_bool(&quot;&quot;)      # True</span>
</span><span id="TypeParser-517"><a href="#TypeParser-517"><span class="linenos"> 517</span></a><span class="sd">			parser.is_bool(&quot;abc&quot;)   # False</span>
</span><span id="TypeParser-518"><a href="#TypeParser-518"><span class="linenos"> 518</span></a><span class="sd">			```</span>
</span><span id="TypeParser-519"><a href="#TypeParser-519"><span class="linenos"> 519</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-520"><a href="#TypeParser-520"><span class="linenos"> 520</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-521"><a href="#TypeParser-521"><span class="linenos"> 521</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-522"><a href="#TypeParser-522"><span class="linenos"> 522</span></a>
</span><span id="TypeParser-523"><a href="#TypeParser-523"><span class="linenos"> 523</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-524"><a href="#TypeParser-524"><span class="linenos"> 524</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser-525"><a href="#TypeParser-525"><span class="linenos"> 525</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">:</span>
</span><span id="TypeParser-526"><a href="#TypeParser-526"><span class="linenos"> 526</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-527"><a href="#TypeParser-527"><span class="linenos"> 527</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">:</span>
</span><span id="TypeParser-528"><a href="#TypeParser-528"><span class="linenos"> 528</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-529"><a href="#TypeParser-529"><span class="linenos"> 529</span></a>
</span><span id="TypeParser-530"><a href="#TypeParser-530"><span class="linenos"> 530</span></a>		<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-531"><a href="#TypeParser-531"><span class="linenos"> 531</span></a>
</span><span id="TypeParser-532"><a href="#TypeParser-532"><span class="linenos"> 532</span></a>
</span><span id="TypeParser-533"><a href="#TypeParser-533"><span class="linenos"> 533</span></a>	<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-534"><a href="#TypeParser-534"><span class="linenos"> 534</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-535"><a href="#TypeParser-535"><span class="linenos"> 535</span></a><span class="sd">			Check if a string represents an int</span>
</span><span id="TypeParser-536"><a href="#TypeParser-536"><span class="linenos"> 536</span></a>
</span><span id="TypeParser-537"><a href="#TypeParser-537"><span class="linenos"> 537</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-538"><a href="#TypeParser-538"><span class="linenos"> 538</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-539"><a href="#TypeParser-539"><span class="linenos"> 539</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-540"><a href="#TypeParser-540"><span class="linenos"> 540</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser-541"><a href="#TypeParser-541"><span class="linenos"> 541</span></a>
</span><span id="TypeParser-542"><a href="#TypeParser-542"><span class="linenos"> 542</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser-543"><a href="#TypeParser-543"><span class="linenos"> 543</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser-544"><a href="#TypeParser-544"><span class="linenos"> 544</span></a>
</span><span id="TypeParser-545"><a href="#TypeParser-545"><span class="linenos"> 545</span></a><span class="sd">			`allow_negative`</span>
</span><span id="TypeParser-546"><a href="#TypeParser-546"><span class="linenos"> 546</span></a><span class="sd">			: whether to accept negative values. Since negative values are always indicated with a negative sign, `allow_sign` must also be True (which is the default setting) for this to have any effect.</span>
</span><span id="TypeParser-547"><a href="#TypeParser-547"><span class="linenos"> 547</span></a>
</span><span id="TypeParser-548"><a href="#TypeParser-548"><span class="linenos"> 548</span></a><span class="sd">			`allow_sign`</span>
</span><span id="TypeParser-549"><a href="#TypeParser-549"><span class="linenos"> 549</span></a><span class="sd">			: whether to accept values prepended with a sign character. If False, it implies that `allow_negative` is False also.</span>
</span><span id="TypeParser-550"><a href="#TypeParser-550"><span class="linenos"> 550</span></a>
</span><span id="TypeParser-551"><a href="#TypeParser-551"><span class="linenos"> 551</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser-552"><a href="#TypeParser-552"><span class="linenos"> 552</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;M&lt;/var&gt; must be an integer and &lt;var&gt;X&lt;/var&gt; must be a non-negative integer, even in cases where the expression would evaluate mathematically to an integer.</span>
</span><span id="TypeParser-553"><a href="#TypeParser-553"><span class="linenos"> 553</span></a>
</span><span id="TypeParser-554"><a href="#TypeParser-554"><span class="linenos"> 554</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-555"><a href="#TypeParser-555"><span class="linenos"> 555</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-556"><a href="#TypeParser-556"><span class="linenos"> 556</span></a><span class="sd">			whether it is an int</span>
</span><span id="TypeParser-557"><a href="#TypeParser-557"><span class="linenos"> 557</span></a>
</span><span id="TypeParser-558"><a href="#TypeParser-558"><span class="linenos"> 558</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-559"><a href="#TypeParser-559"><span class="linenos"> 559</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-560"><a href="#TypeParser-560"><span class="linenos"> 560</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-561"><a href="#TypeParser-561"><span class="linenos"> 561</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-562"><a href="#TypeParser-562"><span class="linenos"> 562</span></a><span class="sd">			parser.is_int(&quot;0&quot;)    # True</span>
</span><span id="TypeParser-563"><a href="#TypeParser-563"><span class="linenos"> 563</span></a><span class="sd">			parser.is_int(&quot;-1&quot;)   # True</span>
</span><span id="TypeParser-564"><a href="#TypeParser-564"><span class="linenos"> 564</span></a><span class="sd">			parser.is_int(&quot;abc&quot;)  # False</span>
</span><span id="TypeParser-565"><a href="#TypeParser-565"><span class="linenos"> 565</span></a><span class="sd">			parser.is_int(&quot;&quot;)     # False</span>
</span><span id="TypeParser-566"><a href="#TypeParser-566"><span class="linenos"> 566</span></a><span class="sd">			```</span>
</span><span id="TypeParser-567"><a href="#TypeParser-567"><span class="linenos"> 567</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-568"><a href="#TypeParser-568"><span class="linenos"> 568</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-569"><a href="#TypeParser-569"><span class="linenos"> 569</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-570"><a href="#TypeParser-570"><span class="linenos"> 570</span></a>
</span><span id="TypeParser-571"><a href="#TypeParser-571"><span class="linenos"> 571</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="TypeParser-572"><a href="#TypeParser-572"><span class="linenos"> 572</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-573"><a href="#TypeParser-573"><span class="linenos"> 573</span></a>
</span><span id="TypeParser-574"><a href="#TypeParser-574"><span class="linenos"> 574</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
</span><span id="TypeParser-575"><a href="#TypeParser-575"><span class="linenos"> 575</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser-576"><a href="#TypeParser-576"><span class="linenos"> 576</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-577"><a href="#TypeParser-577"><span class="linenos"> 577</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
</span><span id="TypeParser-578"><a href="#TypeParser-578"><span class="linenos"> 578</span></a>					<span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
</span><span id="TypeParser-579"><a href="#TypeParser-579"><span class="linenos"> 579</span></a>				<span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
</span><span id="TypeParser-580"><a href="#TypeParser-580"><span class="linenos"> 580</span></a>					<span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
</span><span id="TypeParser-581"><a href="#TypeParser-581"><span class="linenos"> 581</span></a>				<span class="p">)</span>
</span><span id="TypeParser-582"><a href="#TypeParser-582"><span class="linenos"> 582</span></a>
</span><span id="TypeParser-583"><a href="#TypeParser-583"><span class="linenos"> 583</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
</span><span id="TypeParser-584"><a href="#TypeParser-584"><span class="linenos"> 584</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span id="TypeParser-585"><a href="#TypeParser-585"><span class="linenos"> 585</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-586"><a href="#TypeParser-586"><span class="linenos"> 586</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sign</span><span class="p">:</span>
</span><span id="TypeParser-587"><a href="#TypeParser-587"><span class="linenos"> 587</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-588"><a href="#TypeParser-588"><span class="linenos"> 588</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_negative</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
</span><span id="TypeParser-589"><a href="#TypeParser-589"><span class="linenos"> 589</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-590"><a href="#TypeParser-590"><span class="linenos"> 590</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser-591"><a href="#TypeParser-591"><span class="linenos"> 591</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
</span><span id="TypeParser-592"><a href="#TypeParser-592"><span class="linenos"> 592</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-593"><a href="#TypeParser-593"><span class="linenos"> 593</span></a>
</span><span id="TypeParser-594"><a href="#TypeParser-594"><span class="linenos"> 594</span></a>		<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-595"><a href="#TypeParser-595"><span class="linenos"> 595</span></a>		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
</span><span id="TypeParser-596"><a href="#TypeParser-596"><span class="linenos"> 596</span></a>			<span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
</span><span id="TypeParser-597"><a href="#TypeParser-597"><span class="linenos"> 597</span></a>				<span class="k">if</span> <span class="n">prev_separated</span><span class="p">:</span>
</span><span id="TypeParser-598"><a href="#TypeParser-598"><span class="linenos"> 598</span></a>					<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-599"><a href="#TypeParser-599"><span class="linenos"> 599</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="TypeParser-600"><a href="#TypeParser-600"><span class="linenos"> 600</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-601"><a href="#TypeParser-601"><span class="linenos"> 601</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser-602"><a href="#TypeParser-602"><span class="linenos"> 602</span></a>				<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span><span class="p">:</span>
</span><span id="TypeParser-603"><a href="#TypeParser-603"><span class="linenos"> 603</span></a>					<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-604"><a href="#TypeParser-604"><span class="linenos"> 604</span></a>		<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-605"><a href="#TypeParser-605"><span class="linenos"> 605</span></a>
</span><span id="TypeParser-606"><a href="#TypeParser-606"><span class="linenos"> 606</span></a>
</span><span id="TypeParser-607"><a href="#TypeParser-607"><span class="linenos"> 607</span></a>	<span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-608"><a href="#TypeParser-608"><span class="linenos"> 608</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-609"><a href="#TypeParser-609"><span class="linenos"> 609</span></a><span class="sd">			Check if a string represents a float (or equivalently, a Decimal)</span>
</span><span id="TypeParser-610"><a href="#TypeParser-610"><span class="linenos"> 610</span></a>
</span><span id="TypeParser-611"><a href="#TypeParser-611"><span class="linenos"> 611</span></a><span class="sd">			This function will also return True if the string represents an int.</span>
</span><span id="TypeParser-612"><a href="#TypeParser-612"><span class="linenos"> 612</span></a>
</span><span id="TypeParser-613"><a href="#TypeParser-613"><span class="linenos"> 613</span></a><span class="sd">			Alias: `is_decimal()`</span>
</span><span id="TypeParser-614"><a href="#TypeParser-614"><span class="linenos"> 614</span></a>
</span><span id="TypeParser-615"><a href="#TypeParser-615"><span class="linenos"> 615</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-616"><a href="#TypeParser-616"><span class="linenos"> 616</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-617"><a href="#TypeParser-617"><span class="linenos"> 617</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-618"><a href="#TypeParser-618"><span class="linenos"> 618</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser-619"><a href="#TypeParser-619"><span class="linenos"> 619</span></a>
</span><span id="TypeParser-620"><a href="#TypeParser-620"><span class="linenos"> 620</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser-621"><a href="#TypeParser-621"><span class="linenos"> 621</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser-622"><a href="#TypeParser-622"><span class="linenos"> 622</span></a>
</span><span id="TypeParser-623"><a href="#TypeParser-623"><span class="linenos"> 623</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser-624"><a href="#TypeParser-624"><span class="linenos"> 624</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
</span><span id="TypeParser-625"><a href="#TypeParser-625"><span class="linenos"> 625</span></a>
</span><span id="TypeParser-626"><a href="#TypeParser-626"><span class="linenos"> 626</span></a><span class="sd">			`allow_inf`</span>
</span><span id="TypeParser-627"><a href="#TypeParser-627"><span class="linenos"> 627</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.inf_values&lt;/code&gt; (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-628"><a href="#TypeParser-628"><span class="linenos"> 628</span></a>
</span><span id="TypeParser-629"><a href="#TypeParser-629"><span class="linenos"> 629</span></a><span class="sd">			`allow_nan`</span>
</span><span id="TypeParser-630"><a href="#TypeParser-630"><span class="linenos"> 630</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.nan_values&lt;/code&gt; (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-631"><a href="#TypeParser-631"><span class="linenos"> 631</span></a>
</span><span id="TypeParser-632"><a href="#TypeParser-632"><span class="linenos"> 632</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-633"><a href="#TypeParser-633"><span class="linenos"> 633</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-634"><a href="#TypeParser-634"><span class="linenos"> 634</span></a><span class="sd">			whether it is a float or Decimal</span>
</span><span id="TypeParser-635"><a href="#TypeParser-635"><span class="linenos"> 635</span></a>
</span><span id="TypeParser-636"><a href="#TypeParser-636"><span class="linenos"> 636</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-637"><a href="#TypeParser-637"><span class="linenos"> 637</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-638"><a href="#TypeParser-638"><span class="linenos"> 638</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-639"><a href="#TypeParser-639"><span class="linenos"> 639</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-640"><a href="#TypeParser-640"><span class="linenos"> 640</span></a><span class="sd">			parser.is_float(&quot;1.&quot;)       # True</span>
</span><span id="TypeParser-641"><a href="#TypeParser-641"><span class="linenos"> 641</span></a><span class="sd">			parser.is_float(&quot;12.3e-2&quot;)  # True</span>
</span><span id="TypeParser-642"><a href="#TypeParser-642"><span class="linenos"> 642</span></a><span class="sd">			parser.is_float(&quot;abc&quot;)      # False</span>
</span><span id="TypeParser-643"><a href="#TypeParser-643"><span class="linenos"> 643</span></a><span class="sd">			parser.is_float(&quot;&quot;)         # False</span>
</span><span id="TypeParser-644"><a href="#TypeParser-644"><span class="linenos"> 644</span></a><span class="sd">			```</span>
</span><span id="TypeParser-645"><a href="#TypeParser-645"><span class="linenos"> 645</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-646"><a href="#TypeParser-646"><span class="linenos"> 646</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-647"><a href="#TypeParser-647"><span class="linenos"> 647</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-648"><a href="#TypeParser-648"><span class="linenos"> 648</span></a>
</span><span id="TypeParser-649"><a href="#TypeParser-649"><span class="linenos"> 649</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
</span><span id="TypeParser-650"><a href="#TypeParser-650"><span class="linenos"> 650</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser-651"><a href="#TypeParser-651"><span class="linenos"> 651</span></a>
</span><span id="TypeParser-652"><a href="#TypeParser-652"><span class="linenos"> 652</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-653"><a href="#TypeParser-653"><span class="linenos"> 653</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-654"><a href="#TypeParser-654"><span class="linenos"> 654</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-655"><a href="#TypeParser-655"><span class="linenos"> 655</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser-656"><a href="#TypeParser-656"><span class="linenos"> 656</span></a>		<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">:</span>
</span><span id="TypeParser-657"><a href="#TypeParser-657"><span class="linenos"> 657</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-658"><a href="#TypeParser-658"><span class="linenos"> 658</span></a>		<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">:</span>
</span><span id="TypeParser-659"><a href="#TypeParser-659"><span class="linenos"> 659</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-660"><a href="#TypeParser-660"><span class="linenos"> 660</span></a>
</span><span id="TypeParser-661"><a href="#TypeParser-661"><span class="linenos"> 661</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="TypeParser-662"><a href="#TypeParser-662"><span class="linenos"> 662</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-663"><a href="#TypeParser-663"><span class="linenos"> 663</span></a>
</span><span id="TypeParser-664"><a href="#TypeParser-664"><span class="linenos"> 664</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
</span><span id="TypeParser-665"><a href="#TypeParser-665"><span class="linenos"> 665</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser-666"><a href="#TypeParser-666"><span class="linenos"> 666</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-667"><a href="#TypeParser-667"><span class="linenos"> 667</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="TypeParser-668"><a href="#TypeParser-668"><span class="linenos"> 668</span></a>
</span><span id="TypeParser-669"><a href="#TypeParser-669"><span class="linenos"> 669</span></a>		<span class="n">value</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser-670"><a href="#TypeParser-670"><span class="linenos"> 670</span></a>		<span class="k">if</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-671"><a href="#TypeParser-671"><span class="linenos"> 671</span></a>			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
</span><span id="TypeParser-672"><a href="#TypeParser-672"><span class="linenos"> 672</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-673"><a href="#TypeParser-673"><span class="linenos"> 673</span></a>			<span class="k">return</span> <span class="p">(</span>
</span><span id="TypeParser-674"><a href="#TypeParser-674"><span class="linenos"> 674</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
</span><span id="TypeParser-675"><a href="#TypeParser-675"><span class="linenos"> 675</span></a>			<span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
</span><span id="TypeParser-676"><a href="#TypeParser-676"><span class="linenos"> 676</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
</span><span id="TypeParser-677"><a href="#TypeParser-677"><span class="linenos"> 677</span></a>			<span class="p">)</span>
</span><span id="TypeParser-678"><a href="#TypeParser-678"><span class="linenos"> 678</span></a>
</span><span id="TypeParser-679"><a href="#TypeParser-679"><span class="linenos"> 679</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="TypeParser-680"><a href="#TypeParser-680"><span class="linenos"> 680</span></a>
</span><span id="TypeParser-681"><a href="#TypeParser-681"><span class="linenos"> 681</span></a>
</span><span id="TypeParser-682"><a href="#TypeParser-682"><span class="linenos"> 682</span></a>	<span class="k">def</span> <span class="nf">is_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-683"><a href="#TypeParser-683"><span class="linenos"> 683</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-684"><a href="#TypeParser-684"><span class="linenos"> 684</span></a><span class="sd">			Alias of `is_float()`</span>
</span><span id="TypeParser-685"><a href="#TypeParser-685"><span class="linenos"> 685</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-686"><a href="#TypeParser-686"><span class="linenos"> 686</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">)</span>
</span><span id="TypeParser-687"><a href="#TypeParser-687"><span class="linenos"> 687</span></a>
</span><span id="TypeParser-688"><a href="#TypeParser-688"><span class="linenos"> 688</span></a>
</span><span id="TypeParser-689"><a href="#TypeParser-689"><span class="linenos"> 689</span></a>	<span class="k">def</span> <span class="nf">parse_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-690"><a href="#TypeParser-690"><span class="linenos"> 690</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-691"><a href="#TypeParser-691"><span class="linenos"> 691</span></a><span class="sd">			Parse a string and return it as the value None if possible</span>
</span><span id="TypeParser-692"><a href="#TypeParser-692"><span class="linenos"> 692</span></a>
</span><span id="TypeParser-693"><a href="#TypeParser-693"><span class="linenos"> 693</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_values&lt;/code&gt; will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-694"><a href="#TypeParser-694"><span class="linenos"> 694</span></a>
</span><span id="TypeParser-695"><a href="#TypeParser-695"><span class="linenos"> 695</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-696"><a href="#TypeParser-696"><span class="linenos"> 696</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-697"><a href="#TypeParser-697"><span class="linenos"> 697</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-698"><a href="#TypeParser-698"><span class="linenos"> 698</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser-699"><a href="#TypeParser-699"><span class="linenos"> 699</span></a>
</span><span id="TypeParser-700"><a href="#TypeParser-700"><span class="linenos"> 700</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-701"><a href="#TypeParser-701"><span class="linenos"> 701</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-702"><a href="#TypeParser-702"><span class="linenos"> 702</span></a><span class="sd">			parsed None value</span>
</span><span id="TypeParser-703"><a href="#TypeParser-703"><span class="linenos"> 703</span></a>
</span><span id="TypeParser-704"><a href="#TypeParser-704"><span class="linenos"> 704</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-705"><a href="#TypeParser-705"><span class="linenos"> 705</span></a><span class="sd">			------</span>
</span><span id="TypeParser-706"><a href="#TypeParser-706"><span class="linenos"> 706</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser-707"><a href="#TypeParser-707"><span class="linenos"> 707</span></a>
</span><span id="TypeParser-708"><a href="#TypeParser-708"><span class="linenos"> 708</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-709"><a href="#TypeParser-709"><span class="linenos"> 709</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-710"><a href="#TypeParser-710"><span class="linenos"> 710</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-711"><a href="#TypeParser-711"><span class="linenos"> 711</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-712"><a href="#TypeParser-712"><span class="linenos"> 712</span></a><span class="sd">			parser.parse_none(&quot;&quot;)     # None</span>
</span><span id="TypeParser-713"><a href="#TypeParser-713"><span class="linenos"> 713</span></a><span class="sd">			parser.parse_none(&quot;abc&quot;)  # raises ValueError</span>
</span><span id="TypeParser-714"><a href="#TypeParser-714"><span class="linenos"> 714</span></a><span class="sd">			```</span>
</span><span id="TypeParser-715"><a href="#TypeParser-715"><span class="linenos"> 715</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-716"><a href="#TypeParser-716"><span class="linenos"> 716</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-717"><a href="#TypeParser-717"><span class="linenos"> 717</span></a>			<span class="k">return</span> <span class="kc">None</span>
</span><span id="TypeParser-718"><a href="#TypeParser-718"><span class="linenos"> 718</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-719"><a href="#TypeParser-719"><span class="linenos"> 719</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a none value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-720"><a href="#TypeParser-720"><span class="linenos"> 720</span></a>
</span><span id="TypeParser-721"><a href="#TypeParser-721"><span class="linenos"> 721</span></a>
</span><span id="TypeParser-722"><a href="#TypeParser-722"><span class="linenos"> 722</span></a>	<span class="k">def</span> <span class="nf">parse_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-723"><a href="#TypeParser-723"><span class="linenos"> 723</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-724"><a href="#TypeParser-724"><span class="linenos"> 724</span></a><span class="sd">			Parse a string and return it as a bool if possible</span>
</span><span id="TypeParser-725"><a href="#TypeParser-725"><span class="linenos"> 725</span></a>
</span><span id="TypeParser-726"><a href="#TypeParser-726"><span class="linenos"> 726</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.true_values&lt;/code&gt; and &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.false_values&lt;/code&gt; will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.bool_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-727"><a href="#TypeParser-727"><span class="linenos"> 727</span></a>
</span><span id="TypeParser-728"><a href="#TypeParser-728"><span class="linenos"> 728</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-729"><a href="#TypeParser-729"><span class="linenos"> 729</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-730"><a href="#TypeParser-730"><span class="linenos"> 730</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-731"><a href="#TypeParser-731"><span class="linenos"> 731</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser-732"><a href="#TypeParser-732"><span class="linenos"> 732</span></a>
</span><span id="TypeParser-733"><a href="#TypeParser-733"><span class="linenos"> 733</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-734"><a href="#TypeParser-734"><span class="linenos"> 734</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-735"><a href="#TypeParser-735"><span class="linenos"> 735</span></a><span class="sd">			parsed bool value</span>
</span><span id="TypeParser-736"><a href="#TypeParser-736"><span class="linenos"> 736</span></a>
</span><span id="TypeParser-737"><a href="#TypeParser-737"><span class="linenos"> 737</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-738"><a href="#TypeParser-738"><span class="linenos"> 738</span></a><span class="sd">			------</span>
</span><span id="TypeParser-739"><a href="#TypeParser-739"><span class="linenos"> 739</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser-740"><a href="#TypeParser-740"><span class="linenos"> 740</span></a>
</span><span id="TypeParser-741"><a href="#TypeParser-741"><span class="linenos"> 741</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-742"><a href="#TypeParser-742"><span class="linenos"> 742</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-743"><a href="#TypeParser-743"><span class="linenos"> 743</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-744"><a href="#TypeParser-744"><span class="linenos"> 744</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-745"><a href="#TypeParser-745"><span class="linenos"> 745</span></a><span class="sd">			parser.parse_bool(&quot;true&quot;)   # True</span>
</span><span id="TypeParser-746"><a href="#TypeParser-746"><span class="linenos"> 746</span></a><span class="sd">			parser.parse_bool(&quot;FALSE&quot;)  # False</span>
</span><span id="TypeParser-747"><a href="#TypeParser-747"><span class="linenos"> 747</span></a><span class="sd">			```</span>
</span><span id="TypeParser-748"><a href="#TypeParser-748"><span class="linenos"> 748</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-749"><a href="#TypeParser-749"><span class="linenos"> 749</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-750"><a href="#TypeParser-750"><span class="linenos"> 750</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-751"><a href="#TypeParser-751"><span class="linenos"> 751</span></a>
</span><span id="TypeParser-752"><a href="#TypeParser-752"><span class="linenos"> 752</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-753"><a href="#TypeParser-753"><span class="linenos"> 753</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-754"><a href="#TypeParser-754"><span class="linenos"> 754</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-755"><a href="#TypeParser-755"><span class="linenos"> 755</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser-756"><a href="#TypeParser-756"><span class="linenos"> 756</span></a>
</span><span id="TypeParser-757"><a href="#TypeParser-757"><span class="linenos"> 757</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">:</span>
</span><span id="TypeParser-758"><a href="#TypeParser-758"><span class="linenos"> 758</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser-759"><a href="#TypeParser-759"><span class="linenos"> 759</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">:</span>
</span><span id="TypeParser-760"><a href="#TypeParser-760"><span class="linenos"> 760</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser-761"><a href="#TypeParser-761"><span class="linenos"> 761</span></a>
</span><span id="TypeParser-762"><a href="#TypeParser-762"><span class="linenos"> 762</span></a>		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a boolean: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-763"><a href="#TypeParser-763"><span class="linenos"> 763</span></a>
</span><span id="TypeParser-764"><a href="#TypeParser-764"><span class="linenos"> 764</span></a>
</span><span id="TypeParser-765"><a href="#TypeParser-765"><span class="linenos"> 765</span></a>	<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="TypeParser-766"><a href="#TypeParser-766"><span class="linenos"> 766</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-767"><a href="#TypeParser-767"><span class="linenos"> 767</span></a><span class="sd">			Parse a string and return it as an int if possible</span>
</span><span id="TypeParser-768"><a href="#TypeParser-768"><span class="linenos"> 768</span></a>
</span><span id="TypeParser-769"><a href="#TypeParser-769"><span class="linenos"> 769</span></a><span class="sd">			If the string represents a bool, it will be converted to `1` for True and `0` for False.</span>
</span><span id="TypeParser-770"><a href="#TypeParser-770"><span class="linenos"> 770</span></a>
</span><span id="TypeParser-771"><a href="#TypeParser-771"><span class="linenos"> 771</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-772"><a href="#TypeParser-772"><span class="linenos"> 772</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-773"><a href="#TypeParser-773"><span class="linenos"> 773</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-774"><a href="#TypeParser-774"><span class="linenos"> 774</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser-775"><a href="#TypeParser-775"><span class="linenos"> 775</span></a>
</span><span id="TypeParser-776"><a href="#TypeParser-776"><span class="linenos"> 776</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser-777"><a href="#TypeParser-777"><span class="linenos"> 777</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser-778"><a href="#TypeParser-778"><span class="linenos"> 778</span></a>
</span><span id="TypeParser-779"><a href="#TypeParser-779"><span class="linenos"> 779</span></a><span class="sd">			`allow_negative`</span>
</span><span id="TypeParser-780"><a href="#TypeParser-780"><span class="linenos"> 780</span></a><span class="sd">			: whether to accept negative values. Since negative values are always indicated with a negative sign, `allow_sign` must also be True (which is the default setting) for this to have any effect.</span>
</span><span id="TypeParser-781"><a href="#TypeParser-781"><span class="linenos"> 781</span></a>
</span><span id="TypeParser-782"><a href="#TypeParser-782"><span class="linenos"> 782</span></a><span class="sd">			`allow_sign`</span>
</span><span id="TypeParser-783"><a href="#TypeParser-783"><span class="linenos"> 783</span></a><span class="sd">			: whether to accept values prepended with a sign character. If False, it implies that `allow_negative` is False also.</span>
</span><span id="TypeParser-784"><a href="#TypeParser-784"><span class="linenos"> 784</span></a>
</span><span id="TypeParser-785"><a href="#TypeParser-785"><span class="linenos"> 785</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser-786"><a href="#TypeParser-786"><span class="linenos"> 786</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;M&lt;/var&gt; must be an integer and &lt;var&gt;X&lt;/var&gt; must be a non-negative integer, even in cases where the expression would evaluate mathematically to an integer.</span>
</span><span id="TypeParser-787"><a href="#TypeParser-787"><span class="linenos"> 787</span></a>
</span><span id="TypeParser-788"><a href="#TypeParser-788"><span class="linenos"> 788</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-789"><a href="#TypeParser-789"><span class="linenos"> 789</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-790"><a href="#TypeParser-790"><span class="linenos"> 790</span></a><span class="sd">			parsed int value</span>
</span><span id="TypeParser-791"><a href="#TypeParser-791"><span class="linenos"> 791</span></a>
</span><span id="TypeParser-792"><a href="#TypeParser-792"><span class="linenos"> 792</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-793"><a href="#TypeParser-793"><span class="linenos"> 793</span></a><span class="sd">			------</span>
</span><span id="TypeParser-794"><a href="#TypeParser-794"><span class="linenos"> 794</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser-795"><a href="#TypeParser-795"><span class="linenos"> 795</span></a>
</span><span id="TypeParser-796"><a href="#TypeParser-796"><span class="linenos"> 796</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-797"><a href="#TypeParser-797"><span class="linenos"> 797</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-798"><a href="#TypeParser-798"><span class="linenos"> 798</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-799"><a href="#TypeParser-799"><span class="linenos"> 799</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-800"><a href="#TypeParser-800"><span class="linenos"> 800</span></a><span class="sd">			parser.parse_int(&quot;0&quot;)    # 0</span>
</span><span id="TypeParser-801"><a href="#TypeParser-801"><span class="linenos"> 801</span></a><span class="sd">			parser.parse_int(&quot;-1&quot;)   # -1</span>
</span><span id="TypeParser-802"><a href="#TypeParser-802"><span class="linenos"> 802</span></a><span class="sd">			parser.parse_int(&quot;2e3&quot;)  # 2000</span>
</span><span id="TypeParser-803"><a href="#TypeParser-803"><span class="linenos"> 803</span></a><span class="sd">			```</span>
</span><span id="TypeParser-804"><a href="#TypeParser-804"><span class="linenos"> 804</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-805"><a href="#TypeParser-805"><span class="linenos"> 805</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-806"><a href="#TypeParser-806"><span class="linenos"> 806</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-807"><a href="#TypeParser-807"><span class="linenos"> 807</span></a>
</span><span id="TypeParser-808"><a href="#TypeParser-808"><span class="linenos"> 808</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="n">allow_sign</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">):</span>
</span><span id="TypeParser-809"><a href="#TypeParser-809"><span class="linenos"> 809</span></a>			<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
</span><span id="TypeParser-810"><a href="#TypeParser-810"><span class="linenos"> 810</span></a>				<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser-811"><a href="#TypeParser-811"><span class="linenos"> 811</span></a>				<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-812"><a href="#TypeParser-812"><span class="linenos"> 812</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
</span><span id="TypeParser-813"><a href="#TypeParser-813"><span class="linenos"> 813</span></a>						<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser-814"><a href="#TypeParser-814"><span class="linenos"> 814</span></a>					<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
</span><span id="TypeParser-815"><a href="#TypeParser-815"><span class="linenos"> 815</span></a>
</span><span id="TypeParser-816"><a href="#TypeParser-816"><span class="linenos"> 816</span></a>			<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
</span><span id="TypeParser-817"><a href="#TypeParser-817"><span class="linenos"> 817</span></a>				<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser-818"><a href="#TypeParser-818"><span class="linenos"> 818</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-819"><a href="#TypeParser-819"><span class="linenos"> 819</span></a>
</span><span id="TypeParser-820"><a href="#TypeParser-820"><span class="linenos"> 820</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-821"><a href="#TypeParser-821"><span class="linenos"> 821</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser-822"><a href="#TypeParser-822"><span class="linenos"> 822</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-823"><a href="#TypeParser-823"><span class="linenos"> 823</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not an integer: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-824"><a href="#TypeParser-824"><span class="linenos"> 824</span></a>
</span><span id="TypeParser-825"><a href="#TypeParser-825"><span class="linenos"> 825</span></a>
</span><span id="TypeParser-826"><a href="#TypeParser-826"><span class="linenos"> 826</span></a>	<span class="k">def</span> <span class="nf">_parse_floatlike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
</span><span id="TypeParser-827"><a href="#TypeParser-827"><span class="linenos"> 827</span></a>		<span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span><span id="TypeParser-828"><a href="#TypeParser-828"><span class="linenos"> 828</span></a>		<span class="n">converter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]],</span> <span class="n">_FloatLike</span><span class="p">],</span>
</span><span id="TypeParser-829"><a href="#TypeParser-829"><span class="linenos"> 829</span></a>		<span class="n">inf_value</span><span class="p">:</span> <span class="n">_FloatLike</span><span class="p">,</span>
</span><span id="TypeParser-830"><a href="#TypeParser-830"><span class="linenos"> 830</span></a>		<span class="n">nan_value</span><span class="p">:</span> <span class="n">_FloatLike</span><span class="p">,</span>
</span><span id="TypeParser-831"><a href="#TypeParser-831"><span class="linenos"> 831</span></a>		<span class="o">*</span><span class="p">,</span>
</span><span id="TypeParser-832"><a href="#TypeParser-832"><span class="linenos"> 832</span></a>		<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="TypeParser-833"><a href="#TypeParser-833"><span class="linenos"> 833</span></a>		<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="TypeParser-834"><a href="#TypeParser-834"><span class="linenos"> 834</span></a>		<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
</span><span id="TypeParser-835"><a href="#TypeParser-835"><span class="linenos"> 835</span></a>	<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_FloatLike</span><span class="p">:</span>
</span><span id="TypeParser-836"><a href="#TypeParser-836"><span class="linenos"> 836</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-837"><a href="#TypeParser-837"><span class="linenos"> 837</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-838"><a href="#TypeParser-838"><span class="linenos"> 838</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">):</span>
</span><span id="TypeParser-839"><a href="#TypeParser-839"><span class="linenos"> 839</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-840"><a href="#TypeParser-840"><span class="linenos"> 840</span></a>				<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser-841"><a href="#TypeParser-841"><span class="linenos"> 841</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-842"><a href="#TypeParser-842"><span class="linenos"> 842</span></a>				<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser-843"><a href="#TypeParser-843"><span class="linenos"> 843</span></a>			<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">:</span>
</span><span id="TypeParser-844"><a href="#TypeParser-844"><span class="linenos"> 844</span></a>				<span class="k">return</span> <span class="n">inf_value</span>
</span><span id="TypeParser-845"><a href="#TypeParser-845"><span class="linenos"> 845</span></a>			<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">:</span>
</span><span id="TypeParser-846"><a href="#TypeParser-846"><span class="linenos"> 846</span></a>				<span class="k">return</span> <span class="n">nan_value</span>
</span><span id="TypeParser-847"><a href="#TypeParser-847"><span class="linenos"> 847</span></a>
</span><span id="TypeParser-848"><a href="#TypeParser-848"><span class="linenos"> 848</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
</span><span id="TypeParser-849"><a href="#TypeParser-849"><span class="linenos"> 849</span></a>				<span class="n">positive_part</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser-850"><a href="#TypeParser-850"><span class="linenos"> 850</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser-851"><a href="#TypeParser-851"><span class="linenos"> 851</span></a>					<span class="n">special_value</span> <span class="o">=</span> <span class="n">positive_part</span>
</span><span id="TypeParser-852"><a href="#TypeParser-852"><span class="linenos"> 852</span></a>				<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-853"><a href="#TypeParser-853"><span class="linenos"> 853</span></a>					<span class="n">special_value</span> <span class="o">=</span> <span class="n">positive_part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser-854"><a href="#TypeParser-854"><span class="linenos"> 854</span></a>				<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">:</span>
</span><span id="TypeParser-855"><a href="#TypeParser-855"><span class="linenos"> 855</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
</span><span id="TypeParser-856"><a href="#TypeParser-856"><span class="linenos"> 856</span></a>						<span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">inf_value</span>
</span><span id="TypeParser-857"><a href="#TypeParser-857"><span class="linenos"> 857</span></a>					<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-858"><a href="#TypeParser-858"><span class="linenos"> 858</span></a>						<span class="k">return</span> <span class="n">inf_value</span>
</span><span id="TypeParser-859"><a href="#TypeParser-859"><span class="linenos"> 859</span></a>				<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">:</span>
</span><span id="TypeParser-860"><a href="#TypeParser-860"><span class="linenos"> 860</span></a>					<span class="k">return</span> <span class="n">nan_value</span>
</span><span id="TypeParser-861"><a href="#TypeParser-861"><span class="linenos"> 861</span></a>
</span><span id="TypeParser-862"><a href="#TypeParser-862"><span class="linenos"> 862</span></a>				<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
</span><span id="TypeParser-863"><a href="#TypeParser-863"><span class="linenos"> 863</span></a>					<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">positive_part</span>
</span><span id="TypeParser-864"><a href="#TypeParser-864"><span class="linenos"> 864</span></a>			<span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-865"><a href="#TypeParser-865"><span class="linenos"> 865</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-866"><a href="#TypeParser-866"><span class="linenos"> 866</span></a>			<span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser-867"><a href="#TypeParser-867"><span class="linenos"> 867</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-868"><a href="#TypeParser-868"><span class="linenos"> 868</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a </span><span class="si">{</span><span class="n">_FloatLike</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-869"><a href="#TypeParser-869"><span class="linenos"> 869</span></a>
</span><span id="TypeParser-870"><a href="#TypeParser-870"><span class="linenos"> 870</span></a>
</span><span id="TypeParser-871"><a href="#TypeParser-871"><span class="linenos"> 871</span></a>	<span class="k">def</span> <span class="nf">parse_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
</span><span id="TypeParser-872"><a href="#TypeParser-872"><span class="linenos"> 872</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-873"><a href="#TypeParser-873"><span class="linenos"> 873</span></a><span class="sd">			Parse a string and return it as a (non-exact) float if possible</span>
</span><span id="TypeParser-874"><a href="#TypeParser-874"><span class="linenos"> 874</span></a>
</span><span id="TypeParser-875"><a href="#TypeParser-875"><span class="linenos"> 875</span></a><span class="sd">			If the string represents a bool, it will be converted to `1.` for True and `0.` for False. If the string represents an int, it will be converted to a float also.</span>
</span><span id="TypeParser-876"><a href="#TypeParser-876"><span class="linenos"> 876</span></a>
</span><span id="TypeParser-877"><a href="#TypeParser-877"><span class="linenos"> 877</span></a><span class="sd">			Behaves analogously to `parse_decimal()`, except that that returns an exact Decimal instead.</span>
</span><span id="TypeParser-878"><a href="#TypeParser-878"><span class="linenos"> 878</span></a>
</span><span id="TypeParser-879"><a href="#TypeParser-879"><span class="linenos"> 879</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-880"><a href="#TypeParser-880"><span class="linenos"> 880</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-881"><a href="#TypeParser-881"><span class="linenos"> 881</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-882"><a href="#TypeParser-882"><span class="linenos"> 882</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser-883"><a href="#TypeParser-883"><span class="linenos"> 883</span></a>
</span><span id="TypeParser-884"><a href="#TypeParser-884"><span class="linenos"> 884</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser-885"><a href="#TypeParser-885"><span class="linenos"> 885</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser-886"><a href="#TypeParser-886"><span class="linenos"> 886</span></a>
</span><span id="TypeParser-887"><a href="#TypeParser-887"><span class="linenos"> 887</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser-888"><a href="#TypeParser-888"><span class="linenos"> 888</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
</span><span id="TypeParser-889"><a href="#TypeParser-889"><span class="linenos"> 889</span></a>
</span><span id="TypeParser-890"><a href="#TypeParser-890"><span class="linenos"> 890</span></a><span class="sd">			`allow_inf`</span>
</span><span id="TypeParser-891"><a href="#TypeParser-891"><span class="linenos"> 891</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.inf_values&lt;/code&gt; (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-892"><a href="#TypeParser-892"><span class="linenos"> 892</span></a>
</span><span id="TypeParser-893"><a href="#TypeParser-893"><span class="linenos"> 893</span></a><span class="sd">			`allow_nan`</span>
</span><span id="TypeParser-894"><a href="#TypeParser-894"><span class="linenos"> 894</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.nan_values&lt;/code&gt; (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-895"><a href="#TypeParser-895"><span class="linenos"> 895</span></a>
</span><span id="TypeParser-896"><a href="#TypeParser-896"><span class="linenos"> 896</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-897"><a href="#TypeParser-897"><span class="linenos"> 897</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-898"><a href="#TypeParser-898"><span class="linenos"> 898</span></a><span class="sd">			parsed float value</span>
</span><span id="TypeParser-899"><a href="#TypeParser-899"><span class="linenos"> 899</span></a>
</span><span id="TypeParser-900"><a href="#TypeParser-900"><span class="linenos"> 900</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-901"><a href="#TypeParser-901"><span class="linenos"> 901</span></a><span class="sd">			------</span>
</span><span id="TypeParser-902"><a href="#TypeParser-902"><span class="linenos"> 902</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser-903"><a href="#TypeParser-903"><span class="linenos"> 903</span></a>
</span><span id="TypeParser-904"><a href="#TypeParser-904"><span class="linenos"> 904</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-905"><a href="#TypeParser-905"><span class="linenos"> 905</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-906"><a href="#TypeParser-906"><span class="linenos"> 906</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-907"><a href="#TypeParser-907"><span class="linenos"> 907</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
</span><span id="TypeParser-908"><a href="#TypeParser-908"><span class="linenos"> 908</span></a><span class="sd">			parser.parse_float(&quot;1.&quot;)       # 1.</span>
</span><span id="TypeParser-909"><a href="#TypeParser-909"><span class="linenos"> 909</span></a><span class="sd">			parser.parse_float(&quot;1.23e2&quot;)   # 123.</span>
</span><span id="TypeParser-910"><a href="#TypeParser-910"><span class="linenos"> 910</span></a><span class="sd">			parser.parse_float(&quot;1.23e-2&quot;)  # 0.0123</span>
</span><span id="TypeParser-911"><a href="#TypeParser-911"><span class="linenos"> 911</span></a><span class="sd">			parser.parse_float(&quot;inf&quot;)      # math.inf</span>
</span><span id="TypeParser-912"><a href="#TypeParser-912"><span class="linenos"> 912</span></a><span class="sd">			```</span>
</span><span id="TypeParser-913"><a href="#TypeParser-913"><span class="linenos"> 913</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-914"><a href="#TypeParser-914"><span class="linenos"> 914</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
</span><span id="TypeParser-915"><a href="#TypeParser-915"><span class="linenos"> 915</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
</span><span id="TypeParser-916"><a href="#TypeParser-916"><span class="linenos"> 916</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
</span><span id="TypeParser-917"><a href="#TypeParser-917"><span class="linenos"> 917</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
</span><span id="TypeParser-918"><a href="#TypeParser-918"><span class="linenos"> 918</span></a>		<span class="p">)</span>
</span><span id="TypeParser-919"><a href="#TypeParser-919"><span class="linenos"> 919</span></a>
</span><span id="TypeParser-920"><a href="#TypeParser-920"><span class="linenos"> 920</span></a>
</span><span id="TypeParser-921"><a href="#TypeParser-921"><span class="linenos"> 921</span></a>	<span class="k">def</span> <span class="nf">parse_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
</span><span id="TypeParser-922"><a href="#TypeParser-922"><span class="linenos"> 922</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-923"><a href="#TypeParser-923"><span class="linenos"> 923</span></a><span class="sd">			Parse a string and return it as an exact Decimal if possible</span>
</span><span id="TypeParser-924"><a href="#TypeParser-924"><span class="linenos"> 924</span></a>
</span><span id="TypeParser-925"><a href="#TypeParser-925"><span class="linenos"> 925</span></a><span class="sd">			If the string represents a bool, it will be converted to `Decimal(1)` for True and `Decimal(0)` for False. If the string represents an int, it will be converted to a Decimal also.</span>
</span><span id="TypeParser-926"><a href="#TypeParser-926"><span class="linenos"> 926</span></a>
</span><span id="TypeParser-927"><a href="#TypeParser-927"><span class="linenos"> 927</span></a><span class="sd">			Behaves analogously to `parse_float()`, except that that returns a non-exact float instead.</span>
</span><span id="TypeParser-928"><a href="#TypeParser-928"><span class="linenos"> 928</span></a>
</span><span id="TypeParser-929"><a href="#TypeParser-929"><span class="linenos"> 929</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-930"><a href="#TypeParser-930"><span class="linenos"> 930</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-931"><a href="#TypeParser-931"><span class="linenos"> 931</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-932"><a href="#TypeParser-932"><span class="linenos"> 932</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser-933"><a href="#TypeParser-933"><span class="linenos"> 933</span></a>
</span><span id="TypeParser-934"><a href="#TypeParser-934"><span class="linenos"> 934</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser-935"><a href="#TypeParser-935"><span class="linenos"> 935</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser-936"><a href="#TypeParser-936"><span class="linenos"> 936</span></a>
</span><span id="TypeParser-937"><a href="#TypeParser-937"><span class="linenos"> 937</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser-938"><a href="#TypeParser-938"><span class="linenos"> 938</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
</span><span id="TypeParser-939"><a href="#TypeParser-939"><span class="linenos"> 939</span></a>
</span><span id="TypeParser-940"><a href="#TypeParser-940"><span class="linenos"> 940</span></a><span class="sd">			`allow_inf`</span>
</span><span id="TypeParser-941"><a href="#TypeParser-941"><span class="linenos"> 941</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.inf_values&lt;/code&gt; (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-942"><a href="#TypeParser-942"><span class="linenos"> 942</span></a>
</span><span id="TypeParser-943"><a href="#TypeParser-943"><span class="linenos"> 943</span></a><span class="sd">			`allow_nan`</span>
</span><span id="TypeParser-944"><a href="#TypeParser-944"><span class="linenos"> 944</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.nan_values&lt;/code&gt; (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser-945"><a href="#TypeParser-945"><span class="linenos"> 945</span></a>
</span><span id="TypeParser-946"><a href="#TypeParser-946"><span class="linenos"> 946</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-947"><a href="#TypeParser-947"><span class="linenos"> 947</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-948"><a href="#TypeParser-948"><span class="linenos"> 948</span></a><span class="sd">			parsed Decimal value</span>
</span><span id="TypeParser-949"><a href="#TypeParser-949"><span class="linenos"> 949</span></a>
</span><span id="TypeParser-950"><a href="#TypeParser-950"><span class="linenos"> 950</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-951"><a href="#TypeParser-951"><span class="linenos"> 951</span></a><span class="sd">			------</span>
</span><span id="TypeParser-952"><a href="#TypeParser-952"><span class="linenos"> 952</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser-953"><a href="#TypeParser-953"><span class="linenos"> 953</span></a>
</span><span id="TypeParser-954"><a href="#TypeParser-954"><span class="linenos"> 954</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-955"><a href="#TypeParser-955"><span class="linenos"> 955</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-956"><a href="#TypeParser-956"><span class="linenos"> 956</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-957"><a href="#TypeParser-957"><span class="linenos"> 957</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
</span><span id="TypeParser-958"><a href="#TypeParser-958"><span class="linenos"> 958</span></a><span class="sd">			parser.parse_decimal(&quot;1.&quot;)       # Decimal(1)</span>
</span><span id="TypeParser-959"><a href="#TypeParser-959"><span class="linenos"> 959</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e2&quot;)   # Decimal(123)</span>
</span><span id="TypeParser-960"><a href="#TypeParser-960"><span class="linenos"> 960</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e-2&quot;)  # Decimal(123) / Decimal(10000)</span>
</span><span id="TypeParser-961"><a href="#TypeParser-961"><span class="linenos"> 961</span></a><span class="sd">			parser.parse_decimal(&quot;inf&quot;)      # Decimal(math.inf)</span>
</span><span id="TypeParser-962"><a href="#TypeParser-962"><span class="linenos"> 962</span></a><span class="sd">			```</span>
</span><span id="TypeParser-963"><a href="#TypeParser-963"><span class="linenos"> 963</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-964"><a href="#TypeParser-964"><span class="linenos"> 964</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
</span><span id="TypeParser-965"><a href="#TypeParser-965"><span class="linenos"> 965</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
</span><span id="TypeParser-966"><a href="#TypeParser-966"><span class="linenos"> 966</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
</span><span id="TypeParser-967"><a href="#TypeParser-967"><span class="linenos"> 967</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
</span><span id="TypeParser-968"><a href="#TypeParser-968"><span class="linenos"> 968</span></a>		<span class="p">)</span>
</span><span id="TypeParser-969"><a href="#TypeParser-969"><span class="linenos"> 969</span></a>
</span><span id="TypeParser-970"><a href="#TypeParser-970"><span class="linenos"> 970</span></a>
</span><span id="TypeParser-971"><a href="#TypeParser-971"><span class="linenos"> 971</span></a>	<span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
</span><span id="TypeParser-972"><a href="#TypeParser-972"><span class="linenos"> 972</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-973"><a href="#TypeParser-973"><span class="linenos"> 973</span></a><span class="sd">			Infer the underlying type of a string</span>
</span><span id="TypeParser-974"><a href="#TypeParser-974"><span class="linenos"> 974</span></a>
</span><span id="TypeParser-975"><a href="#TypeParser-975"><span class="linenos"> 975</span></a><span class="sd">			Also check for inline lists if &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.list_delimiter&lt;/code&gt; is not None.</span>
</span><span id="TypeParser-976"><a href="#TypeParser-976"><span class="linenos"> 976</span></a>
</span><span id="TypeParser-977"><a href="#TypeParser-977"><span class="linenos"> 977</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-978"><a href="#TypeParser-978"><span class="linenos"> 978</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-979"><a href="#TypeParser-979"><span class="linenos"> 979</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-980"><a href="#TypeParser-980"><span class="linenos"> 980</span></a><span class="sd">			: the string for which the type should be inferred</span>
</span><span id="TypeParser-981"><a href="#TypeParser-981"><span class="linenos"> 981</span></a>
</span><span id="TypeParser-982"><a href="#TypeParser-982"><span class="linenos"> 982</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-983"><a href="#TypeParser-983"><span class="linenos"> 983</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-984"><a href="#TypeParser-984"><span class="linenos"> 984</span></a><span class="sd">			inferred type</span>
</span><span id="TypeParser-985"><a href="#TypeParser-985"><span class="linenos"> 985</span></a>
</span><span id="TypeParser-986"><a href="#TypeParser-986"><span class="linenos"> 986</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-987"><a href="#TypeParser-987"><span class="linenos"> 987</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-988"><a href="#TypeParser-988"><span class="linenos"> 988</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-989"><a href="#TypeParser-989"><span class="linenos"> 989</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-990"><a href="#TypeParser-990"><span class="linenos"> 990</span></a><span class="sd">			parser.infer(&quot;true&quot;)  # bool</span>
</span><span id="TypeParser-991"><a href="#TypeParser-991"><span class="linenos"> 991</span></a><span class="sd">			parser.infer(&quot;2.0&quot;)   # float</span>
</span><span id="TypeParser-992"><a href="#TypeParser-992"><span class="linenos"> 992</span></a><span class="sd">			parser.infer(&quot;abc&quot;)   # str</span>
</span><span id="TypeParser-993"><a href="#TypeParser-993"><span class="linenos"> 993</span></a><span class="sd">			```</span>
</span><span id="TypeParser-994"><a href="#TypeParser-994"><span class="linenos"> 994</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-995"><a href="#TypeParser-995"><span class="linenos"> 995</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-996"><a href="#TypeParser-996"><span class="linenos"> 996</span></a>			<span class="k">return</span> <span class="n">NoneType</span>
</span><span id="TypeParser-997"><a href="#TypeParser-997"><span class="linenos"> 997</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-998"><a href="#TypeParser-998"><span class="linenos"> 998</span></a>			<span class="k">return</span> <span class="nb">bool</span>
</span><span id="TypeParser-999"><a href="#TypeParser-999"><span class="linenos"> 999</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-1000"><a href="#TypeParser-1000"><span class="linenos">1000</span></a>			<span class="k">return</span> <span class="nb">int</span>
</span><span id="TypeParser-1001"><a href="#TypeParser-1001"><span class="linenos">1001</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-1002"><a href="#TypeParser-1002"><span class="linenos">1002</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span><span class="p">:</span>
</span><span id="TypeParser-1003"><a href="#TypeParser-1003"><span class="linenos">1003</span></a>				<span class="k">return</span> <span class="n">Decimal</span>
</span><span id="TypeParser-1004"><a href="#TypeParser-1004"><span class="linenos">1004</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-1005"><a href="#TypeParser-1005"><span class="linenos">1005</span></a>				<span class="k">return</span> <span class="nb">float</span>
</span><span id="TypeParser-1006"><a href="#TypeParser-1006"><span class="linenos">1006</span></a>
</span><span id="TypeParser-1007"><a href="#TypeParser-1007"><span class="linenos">1007</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-1008"><a href="#TypeParser-1008"><span class="linenos">1008</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser-1009"><a href="#TypeParser-1009"><span class="linenos">1009</span></a>
</span><span id="TypeParser-1010"><a href="#TypeParser-1010"><span class="linenos">1010</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
</span><span id="TypeParser-1011"><a href="#TypeParser-1011"><span class="linenos">1011</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">)</span>
</span><span id="TypeParser-1012"><a href="#TypeParser-1012"><span class="linenos">1012</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-1013"><a href="#TypeParser-1013"><span class="linenos">1013</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
</span><span id="TypeParser-1014"><a href="#TypeParser-1014"><span class="linenos">1014</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">subvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">)</span>
</span><span id="TypeParser-1015"><a href="#TypeParser-1015"><span class="linenos">1015</span></a>			<span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">reduced_type</span><span class="p">]</span>
</span><span id="TypeParser-1016"><a href="#TypeParser-1016"><span class="linenos">1016</span></a>			<span class="k">return</span> <span class="n">r</span>
</span><span id="TypeParser-1017"><a href="#TypeParser-1017"><span class="linenos">1017</span></a>
</span><span id="TypeParser-1018"><a href="#TypeParser-1018"><span class="linenos">1018</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
</span><span id="TypeParser-1019"><a href="#TypeParser-1019"><span class="linenos">1019</span></a>
</span><span id="TypeParser-1020"><a href="#TypeParser-1020"><span class="linenos">1020</span></a>
</span><span id="TypeParser-1021"><a href="#TypeParser-1021"><span class="linenos">1021</span></a>	<span class="k">def</span> <span class="nf">infer_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
</span><span id="TypeParser-1022"><a href="#TypeParser-1022"><span class="linenos">1022</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1023"><a href="#TypeParser-1023"><span class="linenos">1023</span></a><span class="sd">			Infer the underlying common type of a series of strings</span>
</span><span id="TypeParser-1024"><a href="#TypeParser-1024"><span class="linenos">1024</span></a>
</span><span id="TypeParser-1025"><a href="#TypeParser-1025"><span class="linenos">1025</span></a><span class="sd">			If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser-1026"><a href="#TypeParser-1026"><span class="linenos">1026</span></a>
</span><span id="TypeParser-1027"><a href="#TypeParser-1027"><span class="linenos">1027</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1028"><a href="#TypeParser-1028"><span class="linenos">1028</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1029"><a href="#TypeParser-1029"><span class="linenos">1029</span></a><span class="sd">			`values`</span>
</span><span id="TypeParser-1030"><a href="#TypeParser-1030"><span class="linenos">1030</span></a><span class="sd">			: series of strings for which the type should be inferred</span>
</span><span id="TypeParser-1031"><a href="#TypeParser-1031"><span class="linenos">1031</span></a>
</span><span id="TypeParser-1032"><a href="#TypeParser-1032"><span class="linenos">1032</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-1033"><a href="#TypeParser-1033"><span class="linenos">1033</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1034"><a href="#TypeParser-1034"><span class="linenos">1034</span></a><span class="sd">			inferred type</span>
</span><span id="TypeParser-1035"><a href="#TypeParser-1035"><span class="linenos">1035</span></a>
</span><span id="TypeParser-1036"><a href="#TypeParser-1036"><span class="linenos">1036</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1037"><a href="#TypeParser-1037"><span class="linenos">1037</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1038"><a href="#TypeParser-1038"><span class="linenos">1038</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1039"><a href="#TypeParser-1039"><span class="linenos">1039</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1040"><a href="#TypeParser-1040"><span class="linenos">1040</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2&quot;, &quot;3.4&quot;])       # float</span>
</span><span id="TypeParser-1041"><a href="#TypeParser-1041"><span class="linenos">1041</span></a><span class="sd">			parser.infer_series([&quot;true&quot;, &quot;false&quot;, &quot;2&quot;])  # int</span>
</span><span id="TypeParser-1042"><a href="#TypeParser-1042"><span class="linenos">1042</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])     # str</span>
</span><span id="TypeParser-1043"><a href="#TypeParser-1043"><span class="linenos">1043</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1044"><a href="#TypeParser-1044"><span class="linenos">1044</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1045"><a href="#TypeParser-1045"><span class="linenos">1045</span></a>		<span class="k">return</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-1046"><a href="#TypeParser-1046"><span class="linenos">1046</span></a>
</span><span id="TypeParser-1047"><a href="#TypeParser-1047"><span class="linenos">1047</span></a>
</span><span id="TypeParser-1048"><a href="#TypeParser-1048"><span class="linenos">1048</span></a>	<span class="k">def</span> <span class="nf">infer_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">]:</span>
</span><span id="TypeParser-1049"><a href="#TypeParser-1049"><span class="linenos">1049</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1050"><a href="#TypeParser-1050"><span class="linenos">1050</span></a><span class="sd">			Infer the underlying common type for each column of a table of strings</span>
</span><span id="TypeParser-1051"><a href="#TypeParser-1051"><span class="linenos">1051</span></a>
</span><span id="TypeParser-1052"><a href="#TypeParser-1052"><span class="linenos">1052</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser-1053"><a href="#TypeParser-1053"><span class="linenos">1053</span></a>
</span><span id="TypeParser-1054"><a href="#TypeParser-1054"><span class="linenos">1054</span></a><span class="sd">			Note that the individual inferred types of every value in the table must be able to fit into memory.</span>
</span><span id="TypeParser-1055"><a href="#TypeParser-1055"><span class="linenos">1055</span></a>
</span><span id="TypeParser-1056"><a href="#TypeParser-1056"><span class="linenos">1056</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1057"><a href="#TypeParser-1057"><span class="linenos">1057</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1058"><a href="#TypeParser-1058"><span class="linenos">1058</span></a><span class="sd">			`rows`</span>
</span><span id="TypeParser-1059"><a href="#TypeParser-1059"><span class="linenos">1059</span></a><span class="sd">			: table of strings for which the types should be inferred, in row-major order</span>
</span><span id="TypeParser-1060"><a href="#TypeParser-1060"><span class="linenos">1060</span></a>
</span><span id="TypeParser-1061"><a href="#TypeParser-1061"><span class="linenos">1061</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-1062"><a href="#TypeParser-1062"><span class="linenos">1062</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1063"><a href="#TypeParser-1063"><span class="linenos">1063</span></a><span class="sd">			inferred types</span>
</span><span id="TypeParser-1064"><a href="#TypeParser-1064"><span class="linenos">1064</span></a>
</span><span id="TypeParser-1065"><a href="#TypeParser-1065"><span class="linenos">1065</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1066"><a href="#TypeParser-1066"><span class="linenos">1066</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1067"><a href="#TypeParser-1067"><span class="linenos">1067</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1068"><a href="#TypeParser-1068"><span class="linenos">1068</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1069"><a href="#TypeParser-1069"><span class="linenos">1069</span></a><span class="sd">			parser.infer_table([</span>
</span><span id="TypeParser-1070"><a href="#TypeParser-1070"><span class="linenos">1070</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
</span><span id="TypeParser-1071"><a href="#TypeParser-1071"><span class="linenos">1071</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
</span><span id="TypeParser-1072"><a href="#TypeParser-1072"><span class="linenos">1072</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
</span><span id="TypeParser-1073"><a href="#TypeParser-1073"><span class="linenos">1073</span></a><span class="sd">			])</span>
</span><span id="TypeParser-1074"><a href="#TypeParser-1074"><span class="linenos">1074</span></a><span class="sd">			# [float, int, str]</span>
</span><span id="TypeParser-1075"><a href="#TypeParser-1075"><span class="linenos">1075</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1076"><a href="#TypeParser-1076"><span class="linenos">1076</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1077"><a href="#TypeParser-1077"><span class="linenos">1077</span></a>		<span class="n">rows_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span><span id="TypeParser-1078"><a href="#TypeParser-1078"><span class="linenos">1078</span></a>		<span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rows_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="TypeParser-1079"><a href="#TypeParser-1079"><span class="linenos">1079</span></a>		<span class="k">if</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser-1080"><a href="#TypeParser-1080"><span class="linenos">1080</span></a>			<span class="k">return</span> <span class="p">[]</span>
</span><span id="TypeParser-1081"><a href="#TypeParser-1081"><span class="linenos">1081</span></a>
</span><span id="TypeParser-1082"><a href="#TypeParser-1082"><span class="linenos">1082</span></a>		<span class="n">num_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">)</span>
</span><span id="TypeParser-1083"><a href="#TypeParser-1083"><span class="linenos">1083</span></a>		<span class="k">if</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="TypeParser-1084"><a href="#TypeParser-1084"><span class="linenos">1084</span></a>			<span class="k">return</span> <span class="p">[]</span>
</span><span id="TypeParser-1085"><a href="#TypeParser-1085"><span class="linenos">1085</span></a>
</span><span id="TypeParser-1086"><a href="#TypeParser-1086"><span class="linenos">1086</span></a>		<span class="n">table</span> <span class="o">=</span> <span class="n">_TypeTable</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">])</span>
</span><span id="TypeParser-1087"><a href="#TypeParser-1087"><span class="linenos">1087</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows_iter</span><span class="p">:</span>
</span><span id="TypeParser-1088"><a href="#TypeParser-1088"><span class="linenos">1088</span></a>			<span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
</span><span id="TypeParser-1089"><a href="#TypeParser-1089"><span class="linenos">1089</span></a>
</span><span id="TypeParser-1090"><a href="#TypeParser-1090"><span class="linenos">1090</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">reduce_types</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
</span><span id="TypeParser-1091"><a href="#TypeParser-1091"><span class="linenos">1091</span></a>
</span><span id="TypeParser-1092"><a href="#TypeParser-1092"><span class="linenos">1092</span></a>
</span><span id="TypeParser-1093"><a href="#TypeParser-1093"><span class="linenos">1093</span></a>	<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_type</span><span class="p">:</span> <span class="n">AnyValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
</span><span id="TypeParser-1094"><a href="#TypeParser-1094"><span class="linenos">1094</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1095"><a href="#TypeParser-1095"><span class="linenos">1095</span></a><span class="sd">			Convert a string to the specified target type if possible</span>
</span><span id="TypeParser-1096"><a href="#TypeParser-1096"><span class="linenos">1096</span></a>
</span><span id="TypeParser-1097"><a href="#TypeParser-1097"><span class="linenos">1097</span></a><span class="sd">			Valid values for `target_type` include any return value from `infer()`, `infer_series()` and `infer_table()`. To infer and convert the string automatically, use `parse()`, `parse_series()` or `parse_table()` instead.</span>
</span><span id="TypeParser-1098"><a href="#TypeParser-1098"><span class="linenos">1098</span></a>
</span><span id="TypeParser-1099"><a href="#TypeParser-1099"><span class="linenos">1099</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1100"><a href="#TypeParser-1100"><span class="linenos">1100</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1101"><a href="#TypeParser-1101"><span class="linenos">1101</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-1102"><a href="#TypeParser-1102"><span class="linenos">1102</span></a><span class="sd">			: the string to be converted</span>
</span><span id="TypeParser-1103"><a href="#TypeParser-1103"><span class="linenos">1103</span></a>
</span><span id="TypeParser-1104"><a href="#TypeParser-1104"><span class="linenos">1104</span></a><span class="sd">			`target_type`</span>
</span><span id="TypeParser-1105"><a href="#TypeParser-1105"><span class="linenos">1105</span></a><span class="sd">			: type to which the value should be converted</span>
</span><span id="TypeParser-1106"><a href="#TypeParser-1106"><span class="linenos">1106</span></a>
</span><span id="TypeParser-1107"><a href="#TypeParser-1107"><span class="linenos">1107</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-1108"><a href="#TypeParser-1108"><span class="linenos">1108</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1109"><a href="#TypeParser-1109"><span class="linenos">1109</span></a><span class="sd">			converted value</span>
</span><span id="TypeParser-1110"><a href="#TypeParser-1110"><span class="linenos">1110</span></a>
</span><span id="TypeParser-1111"><a href="#TypeParser-1111"><span class="linenos">1111</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser-1112"><a href="#TypeParser-1112"><span class="linenos">1112</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1113"><a href="#TypeParser-1113"><span class="linenos">1113</span></a><span class="sd">			`ValueError`</span>
</span><span id="TypeParser-1114"><a href="#TypeParser-1114"><span class="linenos">1114</span></a><span class="sd">			: if `value` cannot be converted to `target_type`</span>
</span><span id="TypeParser-1115"><a href="#TypeParser-1115"><span class="linenos">1115</span></a>
</span><span id="TypeParser-1116"><a href="#TypeParser-1116"><span class="linenos">1116</span></a><span class="sd">			`TypeError`</span>
</span><span id="TypeParser-1117"><a href="#TypeParser-1117"><span class="linenos">1117</span></a><span class="sd">			: if `target_type` is not a valid type</span>
</span><span id="TypeParser-1118"><a href="#TypeParser-1118"><span class="linenos">1118</span></a>
</span><span id="TypeParser-1119"><a href="#TypeParser-1119"><span class="linenos">1119</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1120"><a href="#TypeParser-1120"><span class="linenos">1120</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1121"><a href="#TypeParser-1121"><span class="linenos">1121</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1122"><a href="#TypeParser-1122"><span class="linenos">1122</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1123"><a href="#TypeParser-1123"><span class="linenos">1123</span></a><span class="sd">			parser.convert(&quot;true&quot;, bool)  # True</span>
</span><span id="TypeParser-1124"><a href="#TypeParser-1124"><span class="linenos">1124</span></a><span class="sd">			parser.convert(&quot;2&quot;, int)      # 2</span>
</span><span id="TypeParser-1125"><a href="#TypeParser-1125"><span class="linenos">1125</span></a><span class="sd">			parser.convert(&quot;2&quot;, float)    # 2.</span>
</span><span id="TypeParser-1126"><a href="#TypeParser-1126"><span class="linenos">1126</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1127"><a href="#TypeParser-1127"><span class="linenos">1127</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1128"><a href="#TypeParser-1128"><span class="linenos">1128</span></a>		<span class="n">base</span><span class="p">,</span> <span class="n">type_args</span> <span class="o">=</span> <span class="n">_decompose_type</span><span class="p">(</span><span class="n">target_type</span><span class="p">)</span>
</span><span id="TypeParser-1129"><a href="#TypeParser-1129"><span class="linenos">1129</span></a>		<span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="n">NoneType</span><span class="p">:</span>
</span><span id="TypeParser-1130"><a href="#TypeParser-1130"><span class="linenos">1130</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_none</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-1131"><a href="#TypeParser-1131"><span class="linenos">1131</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser-1132"><a href="#TypeParser-1132"><span class="linenos">1132</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-1133"><a href="#TypeParser-1133"><span class="linenos">1133</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="TypeParser-1134"><a href="#TypeParser-1134"><span class="linenos">1134</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-1135"><a href="#TypeParser-1135"><span class="linenos">1135</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Decimal</span><span class="p">:</span>
</span><span id="TypeParser-1136"><a href="#TypeParser-1136"><span class="linenos">1136</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-1137"><a href="#TypeParser-1137"><span class="linenos">1137</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
</span><span id="TypeParser-1138"><a href="#TypeParser-1138"><span class="linenos">1138</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser-1139"><a href="#TypeParser-1139"><span class="linenos">1139</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-1140"><a href="#TypeParser-1140"><span class="linenos">1140</span></a>			<span class="k">return</span> <span class="n">value</span>
</span><span id="TypeParser-1141"><a href="#TypeParser-1141"><span class="linenos">1141</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Nullable</span><span class="p">:</span>
</span><span id="TypeParser-1142"><a href="#TypeParser-1142"><span class="linenos">1142</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser-1143"><a href="#TypeParser-1143"><span class="linenos">1143</span></a>				<span class="k">return</span> <span class="kc">None</span>
</span><span id="TypeParser-1144"><a href="#TypeParser-1144"><span class="linenos">1144</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-1145"><a href="#TypeParser-1145"><span class="linenos">1145</span></a>				<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-1146"><a href="#TypeParser-1146"><span class="linenos">1146</span></a>					<span class="n">inner_type</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="TypeParser-1147"><a href="#TypeParser-1147"><span class="linenos">1147</span></a>					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inner_type</span><span class="p">)</span>
</span><span id="TypeParser-1148"><a href="#TypeParser-1148"><span class="linenos">1148</span></a>				<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-1149"><a href="#TypeParser-1149"><span class="linenos">1149</span></a>					<span class="k">return</span> <span class="n">value</span>
</span><span id="TypeParser-1150"><a href="#TypeParser-1150"><span class="linenos">1150</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
</span><span id="TypeParser-1151"><a href="#TypeParser-1151"><span class="linenos">1151</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">)</span>
</span><span id="TypeParser-1152"><a href="#TypeParser-1152"><span class="linenos">1152</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser-1153"><a href="#TypeParser-1153"><span class="linenos">1153</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
</span><span id="TypeParser-1154"><a href="#TypeParser-1154"><span class="linenos">1154</span></a>			<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser-1155"><a href="#TypeParser-1155"><span class="linenos">1155</span></a>				<span class="n">subtype</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="TypeParser-1156"><a href="#TypeParser-1156"><span class="linenos">1156</span></a>				<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">subvalue</span><span class="p">,</span> <span class="n">subtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
</span><span id="TypeParser-1157"><a href="#TypeParser-1157"><span class="linenos">1157</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-1158"><a href="#TypeParser-1158"><span class="linenos">1158</span></a>				<span class="k">return</span> <span class="n">subvalues</span>
</span><span id="TypeParser-1159"><a href="#TypeParser-1159"><span class="linenos">1159</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser-1160"><a href="#TypeParser-1160"><span class="linenos">1160</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot convert to type: </span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="TypeParser-1161"><a href="#TypeParser-1161"><span class="linenos">1161</span></a>
</span><span id="TypeParser-1162"><a href="#TypeParser-1162"><span class="linenos">1162</span></a>
</span><span id="TypeParser-1163"><a href="#TypeParser-1163"><span class="linenos">1163</span></a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
</span><span id="TypeParser-1164"><a href="#TypeParser-1164"><span class="linenos">1164</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1165"><a href="#TypeParser-1165"><span class="linenos">1165</span></a><span class="sd">			Parse a string and convert it to its underlying type</span>
</span><span id="TypeParser-1166"><a href="#TypeParser-1166"><span class="linenos">1166</span></a>
</span><span id="TypeParser-1167"><a href="#TypeParser-1167"><span class="linenos">1167</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1168"><a href="#TypeParser-1168"><span class="linenos">1168</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1169"><a href="#TypeParser-1169"><span class="linenos">1169</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser-1170"><a href="#TypeParser-1170"><span class="linenos">1170</span></a><span class="sd">			: the string to be parsed</span>
</span><span id="TypeParser-1171"><a href="#TypeParser-1171"><span class="linenos">1171</span></a>
</span><span id="TypeParser-1172"><a href="#TypeParser-1172"><span class="linenos">1172</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-1173"><a href="#TypeParser-1173"><span class="linenos">1173</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1174"><a href="#TypeParser-1174"><span class="linenos">1174</span></a><span class="sd">			converted value</span>
</span><span id="TypeParser-1175"><a href="#TypeParser-1175"><span class="linenos">1175</span></a>
</span><span id="TypeParser-1176"><a href="#TypeParser-1176"><span class="linenos">1176</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1177"><a href="#TypeParser-1177"><span class="linenos">1177</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1178"><a href="#TypeParser-1178"><span class="linenos">1178</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1179"><a href="#TypeParser-1179"><span class="linenos">1179</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1180"><a href="#TypeParser-1180"><span class="linenos">1180</span></a><span class="sd">			parser.parse(&quot;true&quot;)  # True</span>
</span><span id="TypeParser-1181"><a href="#TypeParser-1181"><span class="linenos">1181</span></a><span class="sd">			parser.parse(&quot;2.0&quot;)   # 2.</span>
</span><span id="TypeParser-1182"><a href="#TypeParser-1182"><span class="linenos">1182</span></a><span class="sd">			parser.parse(&quot;abc&quot;)   # &quot;abc&quot;</span>
</span><span id="TypeParser-1183"><a href="#TypeParser-1183"><span class="linenos">1183</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1184"><a href="#TypeParser-1184"><span class="linenos">1184</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1185"><a href="#TypeParser-1185"><span class="linenos">1185</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser-1186"><a href="#TypeParser-1186"><span class="linenos">1186</span></a>
</span><span id="TypeParser-1187"><a href="#TypeParser-1187"><span class="linenos">1187</span></a>
</span><span id="TypeParser-1188"><a href="#TypeParser-1188"><span class="linenos">1188</span></a>	<span class="k">def</span> <span class="nf">parse_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]:</span>
</span><span id="TypeParser-1189"><a href="#TypeParser-1189"><span class="linenos">1189</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1190"><a href="#TypeParser-1190"><span class="linenos">1190</span></a><span class="sd">			Parse a series of strings and convert them to their underlying common type</span>
</span><span id="TypeParser-1191"><a href="#TypeParser-1191"><span class="linenos">1191</span></a>
</span><span id="TypeParser-1192"><a href="#TypeParser-1192"><span class="linenos">1192</span></a><span class="sd">			If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser-1193"><a href="#TypeParser-1193"><span class="linenos">1193</span></a>
</span><span id="TypeParser-1194"><a href="#TypeParser-1194"><span class="linenos">1194</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1195"><a href="#TypeParser-1195"><span class="linenos">1195</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1196"><a href="#TypeParser-1196"><span class="linenos">1196</span></a><span class="sd">			`values`</span>
</span><span id="TypeParser-1197"><a href="#TypeParser-1197"><span class="linenos">1197</span></a><span class="sd">			: series of strings to be parsed</span>
</span><span id="TypeParser-1198"><a href="#TypeParser-1198"><span class="linenos">1198</span></a>
</span><span id="TypeParser-1199"><a href="#TypeParser-1199"><span class="linenos">1199</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-1200"><a href="#TypeParser-1200"><span class="linenos">1200</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1201"><a href="#TypeParser-1201"><span class="linenos">1201</span></a><span class="sd">			converted values</span>
</span><span id="TypeParser-1202"><a href="#TypeParser-1202"><span class="linenos">1202</span></a>
</span><span id="TypeParser-1203"><a href="#TypeParser-1203"><span class="linenos">1203</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1204"><a href="#TypeParser-1204"><span class="linenos">1204</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1205"><a href="#TypeParser-1205"><span class="linenos">1205</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1206"><a href="#TypeParser-1206"><span class="linenos">1206</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1207"><a href="#TypeParser-1207"><span class="linenos">1207</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])        # [1, 2, 3]</span>
</span><span id="TypeParser-1208"><a href="#TypeParser-1208"><span class="linenos">1208</span></a><span class="sd">			parser.parse_series([&quot;5&quot;, &quot;6.7&quot;, &quot;8.&quot;])     # [5., 6.7, 8.]</span>
</span><span id="TypeParser-1209"><a href="#TypeParser-1209"><span class="linenos">1209</span></a><span class="sd">			parser.parse_series([&quot;true&quot;, &quot;false&quot;, &quot;&quot;])  # [True, False, None]</span>
</span><span id="TypeParser-1210"><a href="#TypeParser-1210"><span class="linenos">1210</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])    # [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
</span><span id="TypeParser-1211"><a href="#TypeParser-1211"><span class="linenos">1211</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1212"><a href="#TypeParser-1212"><span class="linenos">1212</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1213"><a href="#TypeParser-1213"><span class="linenos">1213</span></a>		<span class="n">inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser-1214"><a href="#TypeParser-1214"><span class="linenos">1214</span></a>		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</span><span id="TypeParser-1215"><a href="#TypeParser-1215"><span class="linenos">1215</span></a>
</span><span id="TypeParser-1216"><a href="#TypeParser-1216"><span class="linenos">1216</span></a>
</span><span id="TypeParser-1217"><a href="#TypeParser-1217"><span class="linenos">1217</span></a>	<span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
</span><span id="TypeParser-1218"><a href="#TypeParser-1218"><span class="linenos">1218</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1219"><a href="#TypeParser-1219"><span class="linenos">1219</span></a><span class="sd">			Parse a table of strings and convert them to the underlying common type of each column</span>
</span><span id="TypeParser-1220"><a href="#TypeParser-1220"><span class="linenos">1220</span></a>
</span><span id="TypeParser-1221"><a href="#TypeParser-1221"><span class="linenos">1221</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser-1222"><a href="#TypeParser-1222"><span class="linenos">1222</span></a>
</span><span id="TypeParser-1223"><a href="#TypeParser-1223"><span class="linenos">1223</span></a><span class="sd">			Note that the type to which the values should be converted is determined by `infer_table()`, and so the individual inferred types of every value in the table must be able to fit into memory.</span>
</span><span id="TypeParser-1224"><a href="#TypeParser-1224"><span class="linenos">1224</span></a>
</span><span id="TypeParser-1225"><a href="#TypeParser-1225"><span class="linenos">1225</span></a><span class="sd">			This is a function that computes the entire table and returns it all at once. The generator function `iterate_table()` behaves analogously, except that it computes and yields each row one at a time instead.</span>
</span><span id="TypeParser-1226"><a href="#TypeParser-1226"><span class="linenos">1226</span></a>
</span><span id="TypeParser-1227"><a href="#TypeParser-1227"><span class="linenos">1227</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1228"><a href="#TypeParser-1228"><span class="linenos">1228</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1229"><a href="#TypeParser-1229"><span class="linenos">1229</span></a><span class="sd">			`rows`</span>
</span><span id="TypeParser-1230"><a href="#TypeParser-1230"><span class="linenos">1230</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
</span><span id="TypeParser-1231"><a href="#TypeParser-1231"><span class="linenos">1231</span></a>
</span><span id="TypeParser-1232"><a href="#TypeParser-1232"><span class="linenos">1232</span></a><span class="sd">			`iterator`</span>
</span><span id="TypeParser-1233"><a href="#TypeParser-1233"><span class="linenos">1233</span></a><span class="sd">			: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</span>
</span><span id="TypeParser-1234"><a href="#TypeParser-1234"><span class="linenos">1234</span></a>
</span><span id="TypeParser-1235"><a href="#TypeParser-1235"><span class="linenos">1235</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser-1236"><a href="#TypeParser-1236"><span class="linenos">1236</span></a><span class="sd">			-------</span>
</span><span id="TypeParser-1237"><a href="#TypeParser-1237"><span class="linenos">1237</span></a><span class="sd">			converted table of values, in row-major order</span>
</span><span id="TypeParser-1238"><a href="#TypeParser-1238"><span class="linenos">1238</span></a>
</span><span id="TypeParser-1239"><a href="#TypeParser-1239"><span class="linenos">1239</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1240"><a href="#TypeParser-1240"><span class="linenos">1240</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1241"><a href="#TypeParser-1241"><span class="linenos">1241</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1242"><a href="#TypeParser-1242"><span class="linenos">1242</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1243"><a href="#TypeParser-1243"><span class="linenos">1243</span></a><span class="sd">			table = parser.parse_table([</span>
</span><span id="TypeParser-1244"><a href="#TypeParser-1244"><span class="linenos">1244</span></a><span class="sd">				[&quot;1&quot;, &quot;5&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
</span><span id="TypeParser-1245"><a href="#TypeParser-1245"><span class="linenos">1245</span></a><span class="sd">				[&quot;2&quot;, &quot;6.7&quot;, &quot;false&quot;, &quot;2.3&quot;],</span>
</span><span id="TypeParser-1246"><a href="#TypeParser-1246"><span class="linenos">1246</span></a><span class="sd">				[&quot;3&quot;, &quot;8.0&quot;, &quot;&quot;,      &quot;abc&quot;],</span>
</span><span id="TypeParser-1247"><a href="#TypeParser-1247"><span class="linenos">1247</span></a><span class="sd">			]):</span>
</span><span id="TypeParser-1248"><a href="#TypeParser-1248"><span class="linenos">1248</span></a><span class="sd">			assert table == [</span>
</span><span id="TypeParser-1249"><a href="#TypeParser-1249"><span class="linenos">1249</span></a><span class="sd">				[1, 5.,  True,  &quot;1&quot;],</span>
</span><span id="TypeParser-1250"><a href="#TypeParser-1250"><span class="linenos">1250</span></a><span class="sd">				[2, 6.7, False, &quot;2.3&quot;],</span>
</span><span id="TypeParser-1251"><a href="#TypeParser-1251"><span class="linenos">1251</span></a><span class="sd">				[3, 8.,  None,  &quot;abc&quot;],</span>
</span><span id="TypeParser-1252"><a href="#TypeParser-1252"><span class="linenos">1252</span></a><span class="sd">			]</span>
</span><span id="TypeParser-1253"><a href="#TypeParser-1253"><span class="linenos">1253</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1254"><a href="#TypeParser-1254"><span class="linenos">1254</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1255"><a href="#TypeParser-1255"><span class="linenos">1255</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">converted_row</span> <span class="k">for</span> <span class="n">converted_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
</span><span id="TypeParser-1256"><a href="#TypeParser-1256"><span class="linenos">1256</span></a>
</span><span id="TypeParser-1257"><a href="#TypeParser-1257"><span class="linenos">1257</span></a>
</span><span id="TypeParser-1258"><a href="#TypeParser-1258"><span class="linenos">1258</span></a>	<span class="k">def</span> <span class="nf">iterate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
</span><span id="TypeParser-1259"><a href="#TypeParser-1259"><span class="linenos">1259</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser-1260"><a href="#TypeParser-1260"><span class="linenos">1260</span></a><span class="sd">			Parse a table of strings for the underlying common type of each column, then convert and yield each row</span>
</span><span id="TypeParser-1261"><a href="#TypeParser-1261"><span class="linenos">1261</span></a>
</span><span id="TypeParser-1262"><a href="#TypeParser-1262"><span class="linenos">1262</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser-1263"><a href="#TypeParser-1263"><span class="linenos">1263</span></a>
</span><span id="TypeParser-1264"><a href="#TypeParser-1264"><span class="linenos">1264</span></a><span class="sd">			This is a generator function that computes and yields each row one at a time. However, note that in order to determine the types to which each column should be converted, the individual inferred types of every value in the table must still be able to fit into memory.</span>
</span><span id="TypeParser-1265"><a href="#TypeParser-1265"><span class="linenos">1265</span></a>
</span><span id="TypeParser-1266"><a href="#TypeParser-1266"><span class="linenos">1266</span></a><span class="sd">			The function `parse_table()` behaves analogously, except that it computes the entire table and returns it as a list of lists instead.</span>
</span><span id="TypeParser-1267"><a href="#TypeParser-1267"><span class="linenos">1267</span></a>
</span><span id="TypeParser-1268"><a href="#TypeParser-1268"><span class="linenos">1268</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser-1269"><a href="#TypeParser-1269"><span class="linenos">1269</span></a><span class="sd">			---------</span>
</span><span id="TypeParser-1270"><a href="#TypeParser-1270"><span class="linenos">1270</span></a><span class="sd">			`rows`</span>
</span><span id="TypeParser-1271"><a href="#TypeParser-1271"><span class="linenos">1271</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
</span><span id="TypeParser-1272"><a href="#TypeParser-1272"><span class="linenos">1272</span></a>
</span><span id="TypeParser-1273"><a href="#TypeParser-1273"><span class="linenos">1273</span></a><span class="sd">			Yields</span>
</span><span id="TypeParser-1274"><a href="#TypeParser-1274"><span class="linenos">1274</span></a><span class="sd">			------</span>
</span><span id="TypeParser-1275"><a href="#TypeParser-1275"><span class="linenos">1275</span></a><span class="sd">			each row of converted table values</span>
</span><span id="TypeParser-1276"><a href="#TypeParser-1276"><span class="linenos">1276</span></a>
</span><span id="TypeParser-1277"><a href="#TypeParser-1277"><span class="linenos">1277</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser-1278"><a href="#TypeParser-1278"><span class="linenos">1278</span></a><span class="sd">			--------</span>
</span><span id="TypeParser-1279"><a href="#TypeParser-1279"><span class="linenos">1279</span></a><span class="sd">			```python</span>
</span><span id="TypeParser-1280"><a href="#TypeParser-1280"><span class="linenos">1280</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser-1281"><a href="#TypeParser-1281"><span class="linenos">1281</span></a><span class="sd">			table = parser.iterate_table([</span>
</span><span id="TypeParser-1282"><a href="#TypeParser-1282"><span class="linenos">1282</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
</span><span id="TypeParser-1283"><a href="#TypeParser-1283"><span class="linenos">1283</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
</span><span id="TypeParser-1284"><a href="#TypeParser-1284"><span class="linenos">1284</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
</span><span id="TypeParser-1285"><a href="#TypeParser-1285"><span class="linenos">1285</span></a><span class="sd">			]):</span>
</span><span id="TypeParser-1286"><a href="#TypeParser-1286"><span class="linenos">1286</span></a><span class="sd">			assert next(table) == [1.,  1, &quot;1&quot;]</span>
</span><span id="TypeParser-1287"><a href="#TypeParser-1287"><span class="linenos">1287</span></a><span class="sd">			assert next(table) == [2.,  0, &quot;2.3&quot;]</span>
</span><span id="TypeParser-1288"><a href="#TypeParser-1288"><span class="linenos">1288</span></a><span class="sd">			assert next(table) == [3.4, 2, &quot;abc&quot;]</span>
</span><span id="TypeParser-1289"><a href="#TypeParser-1289"><span class="linenos">1289</span></a><span class="sd">			```</span>
</span><span id="TypeParser-1290"><a href="#TypeParser-1290"><span class="linenos">1290</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser-1291"><a href="#TypeParser-1291"><span class="linenos">1291</span></a>		<span class="n">inferred_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span><span id="TypeParser-1292"><a href="#TypeParser-1292"><span class="linenos">1292</span></a>
</span><span id="TypeParser-1293"><a href="#TypeParser-1293"><span class="linenos">1293</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
</span><span id="TypeParser-1294"><a href="#TypeParser-1294"><span class="linenos">1294</span></a>			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">inferred_types</span><span class="p">)]</span>
</span></pre></div>


    <div class="docstring">
<p>A parser that can be used to infer the underlying types of data serialised as strings, and to convert them into their original underlying types.</p>

<p>The behaviour of the parser and the type inference can be configured either in the constructor or using mutable properties of a parser instance. See the constructor documentation for the list of available options.</p></div>


                            <div id="TypeParser.__init__" class="classattr">
                                        <input id="TypeParser.__init__-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="name">TypeParser</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">list_delimiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;true&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;false&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>,</span><span class="param">	<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>,</span><span class="param">	<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">case_sensitive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></span>)</span>


                <label class="view-source-button" for="TypeParser.__init__-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.__init__"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.__init__-67"><a href="#TypeParser.__init__-67"><span class="linenos"> 67</span></a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
</span><span id="TypeParser.__init__-68"><a href="#TypeParser.__init__-68"><span class="linenos"> 68</span></a>		<span class="o">*</span><span class="p">,</span>
</span><span id="TypeParser.__init__-69"><a href="#TypeParser.__init__-69"><span class="linenos"> 69</span></a>		<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</span><span id="TypeParser.__init__-70"><a href="#TypeParser.__init__-70"><span class="linenos"> 70</span></a>		<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser.__init__-71"><a href="#TypeParser.__init__-71"><span class="linenos"> 71</span></a>		<span class="n">list_delimiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span><span id="TypeParser.__init__-72"><a href="#TypeParser.__init__-72"><span class="linenos"> 72</span></a>		<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
</span><span id="TypeParser.__init__-73"><a href="#TypeParser.__init__-73"><span class="linenos"> 73</span></a>		<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser.__init__-74"><a href="#TypeParser.__init__-74"><span class="linenos"> 74</span></a>		<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">],</span>
</span><span id="TypeParser.__init__-75"><a href="#TypeParser.__init__-75"><span class="linenos"> 75</span></a>		<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">],</span>
</span><span id="TypeParser.__init__-76"><a href="#TypeParser.__init__-76"><span class="linenos"> 76</span></a>		<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser.__init__-77"><a href="#TypeParser.__init__-77"><span class="linenos"> 77</span></a>		<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser.__init__-78"><a href="#TypeParser.__init__-78"><span class="linenos"> 78</span></a>		<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
</span><span id="TypeParser.__init__-79"><a href="#TypeParser.__init__-79"><span class="linenos"> 79</span></a>		<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
</span><span id="TypeParser.__init__-80"><a href="#TypeParser.__init__-80"><span class="linenos"> 80</span></a>		<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="TypeParser.__init__-81"><a href="#TypeParser.__init__-81"><span class="linenos"> 81</span></a>		<span class="n">case_sensitive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span><span id="TypeParser.__init__-82"><a href="#TypeParser.__init__-82"><span class="linenos"> 82</span></a>	<span class="p">):</span>
</span><span id="TypeParser.__init__-83"><a href="#TypeParser.__init__-83"><span class="linenos"> 83</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.__init__-84"><a href="#TypeParser.__init__-84"><span class="linenos"> 84</span></a><span class="sd">			Initialise a new parser</span>
</span><span id="TypeParser.__init__-85"><a href="#TypeParser.__init__-85"><span class="linenos"> 85</span></a>
</span><span id="TypeParser.__init__-86"><a href="#TypeParser.__init__-86"><span class="linenos"> 86</span></a><span class="sd">			The behaviour of the parser and the type inference can be configured either in the constructor or using mutable properties of a parser instance. For example,</span>
</span><span id="TypeParser.__init__-87"><a href="#TypeParser.__init__-87"><span class="linenos"> 87</span></a>
</span><span id="TypeParser.__init__-88"><a href="#TypeParser.__init__-88"><span class="linenos"> 88</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.__init__-89"><a href="#TypeParser.__init__-89"><span class="linenos"> 89</span></a><span class="sd">			parser = TypeParser(list_delimiter=&quot;,&quot;)</span>
</span><span id="TypeParser.__init__-90"><a href="#TypeParser.__init__-90"><span class="linenos"> 90</span></a><span class="sd">			assert parser.list_delimiter == &quot;,&quot;</span>
</span><span id="TypeParser.__init__-91"><a href="#TypeParser.__init__-91"><span class="linenos"> 91</span></a><span class="sd">			parser.list_delimiter = &quot;;&quot;</span>
</span><span id="TypeParser.__init__-92"><a href="#TypeParser.__init__-92"><span class="linenos"> 92</span></a><span class="sd">			assert parser.list_delimiter == &quot;;&quot;</span>
</span><span id="TypeParser.__init__-93"><a href="#TypeParser.__init__-93"><span class="linenos"> 93</span></a><span class="sd">			```</span>
</span><span id="TypeParser.__init__-94"><a href="#TypeParser.__init__-94"><span class="linenos"> 94</span></a>
</span><span id="TypeParser.__init__-95"><a href="#TypeParser.__init__-95"><span class="linenos"> 95</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser.__init__-96"><a href="#TypeParser.__init__-96"><span class="linenos"> 96</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser.__init__-97"><a href="#TypeParser.__init__-97"><span class="linenos"> 97</span></a><span class="sd">			`trim`</span>
</span><span id="TypeParser.__init__-98"><a href="#TypeParser.__init__-98"><span class="linenos"> 98</span></a><span class="sd">			: whether leading and trailing whitespace should be stripped from strings</span>
</span><span id="TypeParser.__init__-99"><a href="#TypeParser.__init__-99"><span class="linenos"> 99</span></a>
</span><span id="TypeParser.__init__-100"><a href="#TypeParser.__init__-100"><span class="linenos">100</span></a><span class="sd">			`use_decimal`</span>
</span><span id="TypeParser.__init__-101"><a href="#TypeParser.__init__-101"><span class="linenos">101</span></a><span class="sd">			: whether non-integer numeric values should be inferred to be Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer the type (`infer()` `infer_series()`, `infer_table()`), and does not affect methods where the type is explicitly specified (`is_float()`, `is_decimal()`, `parse_float()`, `parse_decimal()`).</span>
</span><span id="TypeParser.__init__-102"><a href="#TypeParser.__init__-102"><span class="linenos">102</span></a>
</span><span id="TypeParser.__init__-103"><a href="#TypeParser.__init__-103"><span class="linenos">103</span></a><span class="sd">			`list_delimiter`</span>
</span><span id="TypeParser.__init__-104"><a href="#TypeParser.__init__-104"><span class="linenos">104</span></a><span class="sd">			: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead. Note that this setting is unaffected by &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.trim&lt;/code&gt; and &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.case_sensitive&lt;/code&gt;, and will always be used verbatim.</span>
</span><span id="TypeParser.__init__-105"><a href="#TypeParser.__init__-105"><span class="linenos">105</span></a>
</span><span id="TypeParser.__init__-106"><a href="#TypeParser.__init__-106"><span class="linenos">106</span></a><span class="sd">			`none_values`</span>
</span><span id="TypeParser.__init__-107"><a href="#TypeParser.__init__-107"><span class="linenos">107</span></a><span class="sd">			: list of strings that represent the value `None`</span>
</span><span id="TypeParser.__init__-108"><a href="#TypeParser.__init__-108"><span class="linenos">108</span></a>
</span><span id="TypeParser.__init__-109"><a href="#TypeParser.__init__-109"><span class="linenos">109</span></a><span class="sd">			`none_case_sensitive`</span>
</span><span id="TypeParser.__init__-110"><a href="#TypeParser.__init__-110"><span class="linenos">110</span></a><span class="sd">			: whether matches against `none_values` should be made in a case-sensitive manner</span>
</span><span id="TypeParser.__init__-111"><a href="#TypeParser.__init__-111"><span class="linenos">111</span></a>
</span><span id="TypeParser.__init__-112"><a href="#TypeParser.__init__-112"><span class="linenos">112</span></a><span class="sd">			`true_values`</span>
</span><span id="TypeParser.__init__-113"><a href="#TypeParser.__init__-113"><span class="linenos">113</span></a><span class="sd">			: list of strings that represent the bool value `True`</span>
</span><span id="TypeParser.__init__-114"><a href="#TypeParser.__init__-114"><span class="linenos">114</span></a>
</span><span id="TypeParser.__init__-115"><a href="#TypeParser.__init__-115"><span class="linenos">115</span></a><span class="sd">			`false_values`</span>
</span><span id="TypeParser.__init__-116"><a href="#TypeParser.__init__-116"><span class="linenos">116</span></a><span class="sd">			: list of strings that represent the bool value `False`</span>
</span><span id="TypeParser.__init__-117"><a href="#TypeParser.__init__-117"><span class="linenos">117</span></a>
</span><span id="TypeParser.__init__-118"><a href="#TypeParser.__init__-118"><span class="linenos">118</span></a><span class="sd">			`bool_case_sensitive`</span>
</span><span id="TypeParser.__init__-119"><a href="#TypeParser.__init__-119"><span class="linenos">119</span></a><span class="sd">			: whether matches against `true_values` and `false_values` should be made in a case-sensitive manner</span>
</span><span id="TypeParser.__init__-120"><a href="#TypeParser.__init__-120"><span class="linenos">120</span></a>
</span><span id="TypeParser.__init__-121"><a href="#TypeParser.__init__-121"><span class="linenos">121</span></a><span class="sd">			`int_case_sensitive`</span>
</span><span id="TypeParser.__init__-122"><a href="#TypeParser.__init__-122"><span class="linenos">122</span></a><span class="sd">			: whether checks for int should be done in a case-sensitive manner. This only applies to values given in scientific notation, where the mantissa and exponent usually are separated by `e`.</span>
</span><span id="TypeParser.__init__-123"><a href="#TypeParser.__init__-123"><span class="linenos">123</span></a>
</span><span id="TypeParser.__init__-124"><a href="#TypeParser.__init__-124"><span class="linenos">124</span></a><span class="sd">			`inf_values`</span>
</span><span id="TypeParser.__init__-125"><a href="#TypeParser.__init__-125"><span class="linenos">125</span></a><span class="sd">			: list of strings that represent the float or Decimal value of infinity. Each of the strings can also be prepended with a negative sign to represent negative infinity.</span>
</span><span id="TypeParser.__init__-126"><a href="#TypeParser.__init__-126"><span class="linenos">126</span></a>
</span><span id="TypeParser.__init__-127"><a href="#TypeParser.__init__-127"><span class="linenos">127</span></a><span class="sd">			`nan_values`</span>
</span><span id="TypeParser.__init__-128"><a href="#TypeParser.__init__-128"><span class="linenos">128</span></a><span class="sd">			: list of strings that represent a float or Decimal that is NaN (not a number)</span>
</span><span id="TypeParser.__init__-129"><a href="#TypeParser.__init__-129"><span class="linenos">129</span></a>
</span><span id="TypeParser.__init__-130"><a href="#TypeParser.__init__-130"><span class="linenos">130</span></a><span class="sd">			`float_case_sensitive`</span>
</span><span id="TypeParser.__init__-131"><a href="#TypeParser.__init__-131"><span class="linenos">131</span></a><span class="sd">			: whether checks for float or Decimal should be done in a case-sensitive manner. This applies to matches against `inf_values` and `nan_values`, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by `e`.</span>
</span><span id="TypeParser.__init__-132"><a href="#TypeParser.__init__-132"><span class="linenos">132</span></a>
</span><span id="TypeParser.__init__-133"><a href="#TypeParser.__init__-133"><span class="linenos">133</span></a><span class="sd">			`case_sensitive`</span>
</span><span id="TypeParser.__init__-134"><a href="#TypeParser.__init__-134"><span class="linenos">134</span></a><span class="sd">			: whether all matches should be made in a case-sensitive manner. Sets all of `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`, `float_case_sensitive` to the same value, discarding any individual settings.</span>
</span><span id="TypeParser.__init__-135"><a href="#TypeParser.__init__-135"><span class="linenos">135</span></a>
</span><span id="TypeParser.__init__-136"><a href="#TypeParser.__init__-136"><span class="linenos">136</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.__init__-137"><a href="#TypeParser.__init__-137"><span class="linenos">137</span></a><span class="sd">			------</span>
</span><span id="TypeParser.__init__-138"><a href="#TypeParser.__init__-138"><span class="linenos">138</span></a><span class="sd">			`ValueError` if any of the options would lead to ambiguities during parsing</span>
</span><span id="TypeParser.__init__-139"><a href="#TypeParser.__init__-139"><span class="linenos">139</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.__init__-140"><a href="#TypeParser.__init__-140"><span class="linenos">140</span></a>
</span><span id="TypeParser.__init__-141"><a href="#TypeParser.__init__-141"><span class="linenos">141</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.__init__-142"><a href="#TypeParser.__init__-142"><span class="linenos">142</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.__init__-143"><a href="#TypeParser.__init__-143"><span class="linenos">143</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="TypeParser.__init__-144"><a href="#TypeParser.__init__-144"><span class="linenos">144</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-145"><a href="#TypeParser.__init__-145"><span class="linenos">145</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_none_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-146"><a href="#TypeParser.__init__-146"><span class="linenos">146</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.__init__-147"><a href="#TypeParser.__init__-147"><span class="linenos">147</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-148"><a href="#TypeParser.__init__-148"><span class="linenos">148</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_true_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-149"><a href="#TypeParser.__init__-149"><span class="linenos">149</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-150"><a href="#TypeParser.__init__-150"><span class="linenos">150</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_false_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-151"><a href="#TypeParser.__init__-151"><span class="linenos">151</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.__init__-152"><a href="#TypeParser.__init__-152"><span class="linenos">152</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.__init__-153"><a href="#TypeParser.__init__-153"><span class="linenos">153</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-154"><a href="#TypeParser.__init__-154"><span class="linenos">154</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_inf_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-155"><a href="#TypeParser.__init__-155"><span class="linenos">155</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-156"><a href="#TypeParser.__init__-156"><span class="linenos">156</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_original_nan_values</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="TypeParser.__init__-157"><a href="#TypeParser.__init__-157"><span class="linenos">157</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.__init__-158"><a href="#TypeParser.__init__-158"><span class="linenos">158</span></a>
</span><span id="TypeParser.__init__-159"><a href="#TypeParser.__init__-159"><span class="linenos">159</span></a>		<span class="c1"># Unconfigurable default values</span>
</span><span id="TypeParser.__init__-160"><a href="#TypeParser.__init__-160"><span class="linenos">160</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
</span><span id="TypeParser.__init__-161"><a href="#TypeParser.__init__-161"><span class="linenos">161</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">,</span> <span class="s2">&quot;−&quot;</span><span class="p">}</span>
</span><span id="TypeParser.__init__-162"><a href="#TypeParser.__init__-162"><span class="linenos">162</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">}</span>
</span><span id="TypeParser.__init__-163"><a href="#TypeParser.__init__-163"><span class="linenos">163</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">}</span>  <span class="c1"># Because isdigit(&quot;²&quot;) == True, but int(&quot;²&quot;) is invalid</span>
</span><span id="TypeParser.__init__-164"><a href="#TypeParser.__init__-164"><span class="linenos">164</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_&quot;</span><span class="p">}</span>
</span><span id="TypeParser.__init__-165"><a href="#TypeParser.__init__-165"><span class="linenos">165</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
</span><span id="TypeParser.__init__-166"><a href="#TypeParser.__init__-166"><span class="linenos">166</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
</span><span id="TypeParser.__init__-167"><a href="#TypeParser.__init__-167"><span class="linenos">167</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">}</span>
</span><span id="TypeParser.__init__-168"><a href="#TypeParser.__init__-168"><span class="linenos">168</span></a>		<span class="c1"># special_chars = self._reserved_chars | self._list_delimiter</span>
</span><span id="TypeParser.__init__-169"><a href="#TypeParser.__init__-169"><span class="linenos">169</span></a>
</span><span id="TypeParser.__init__-170"><a href="#TypeParser.__init__-170"><span class="linenos">170</span></a>		<span class="c1"># Configured values</span>
</span><span id="TypeParser.__init__-171"><a href="#TypeParser.__init__-171"><span class="linenos">171</span></a>
</span><span id="TypeParser.__init__-172"><a href="#TypeParser.__init__-172"><span class="linenos">172</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span>
</span><span id="TypeParser.__init__-173"><a href="#TypeParser.__init__-173"><span class="linenos">173</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span> <span class="o">=</span> <span class="n">use_decimal</span>
</span><span id="TypeParser.__init__-174"><a href="#TypeParser.__init__-174"><span class="linenos">174</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="n">list_delimiter</span>
</span><span id="TypeParser.__init__-175"><a href="#TypeParser.__init__-175"><span class="linenos">175</span></a>
</span><span id="TypeParser.__init__-176"><a href="#TypeParser.__init__-176"><span class="linenos">176</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">none_case_sensitive</span>
</span><span id="TypeParser.__init__-177"><a href="#TypeParser.__init__-177"><span class="linenos">177</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">bool_case_sensitive</span>
</span><span id="TypeParser.__init__-178"><a href="#TypeParser.__init__-178"><span class="linenos">178</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">int_case_sensitive</span>
</span><span id="TypeParser.__init__-179"><a href="#TypeParser.__init__-179"><span class="linenos">179</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">float_case_sensitive</span>
</span><span id="TypeParser.__init__-180"><a href="#TypeParser.__init__-180"><span class="linenos">180</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
</span><span id="TypeParser.__init__-181"><a href="#TypeParser.__init__-181"><span class="linenos">181</span></a>
</span><span id="TypeParser.__init__-182"><a href="#TypeParser.__init__-182"><span class="linenos">182</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="n">none_values</span>
</span><span id="TypeParser.__init__-183"><a href="#TypeParser.__init__-183"><span class="linenos">183</span></a>
</span><span id="TypeParser.__init__-184"><a href="#TypeParser.__init__-184"><span class="linenos">184</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="n">true_values</span>
</span><span id="TypeParser.__init__-185"><a href="#TypeParser.__init__-185"><span class="linenos">185</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="n">false_values</span>
</span><span id="TypeParser.__init__-186"><a href="#TypeParser.__init__-186"><span class="linenos">186</span></a>
</span><span id="TypeParser.__init__-187"><a href="#TypeParser.__init__-187"><span class="linenos">187</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="n">inf_values</span>
</span><span id="TypeParser.__init__-188"><a href="#TypeParser.__init__-188"><span class="linenos">188</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="n">nan_values</span>
</span><span id="TypeParser.__init__-189"><a href="#TypeParser.__init__-189"><span class="linenos">189</span></a>
</span><span id="TypeParser.__init__-190"><a href="#TypeParser.__init__-190"><span class="linenos">190</span></a>		<span class="c1"># Check if any special values conflict</span>
</span><span id="TypeParser.__init__-191"><a href="#TypeParser.__init__-191"><span class="linenos">191</span></a>		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">special_values</span> <span class="ow">in</span> <span class="p">[</span>
</span><span id="TypeParser.__init__-192"><a href="#TypeParser.__init__-192"><span class="linenos">192</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]),</span>
</span><span id="TypeParser.__init__-193"><a href="#TypeParser.__init__-193"><span class="linenos">193</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span><span class="p">),</span>
</span><span id="TypeParser.__init__-194"><a href="#TypeParser.__init__-194"><span class="linenos">194</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">),</span>
</span><span id="TypeParser.__init__-195"><a href="#TypeParser.__init__-195"><span class="linenos">195</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">),</span>
</span><span id="TypeParser.__init__-196"><a href="#TypeParser.__init__-196"><span class="linenos">196</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">),</span>
</span><span id="TypeParser.__init__-197"><a href="#TypeParser.__init__-197"><span class="linenos">197</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">),</span>
</span><span id="TypeParser.__init__-198"><a href="#TypeParser.__init__-198"><span class="linenos">198</span></a>		<span class="p">]:</span>
</span><span id="TypeParser.__init__-199"><a href="#TypeParser.__init__-199"><span class="linenos">199</span></a>			<span class="k">for</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="n">special_values</span><span class="p">:</span>
</span><span id="TypeParser.__init__-200"><a href="#TypeParser.__init__-200"><span class="linenos">200</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">_validate_special</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">special_value</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Initialise a new parser</p>

<p>The behaviour of the parser and the type inference can be configured either in the constructor or using mutable properties of a parser instance. For example,</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">(</span><span class="n">list_delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">parser</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span>
<span class="n">parser</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="s2">&quot;;&quot;</span>
<span class="k">assert</span> <span class="n">parser</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">==</span> <span class="s2">&quot;;&quot;</span>
</code></pre>
</div>

<h2 id="keyword-arguments">Keyword arguments</h2>

<p><code>trim</code>
: whether leading and trailing whitespace should be stripped from strings</p>

<p><code>use_decimal</code>
: whether non-integer numeric values should be inferred to be Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer the type (<code><a href="#TypeParser.infer">infer()</a></code> <code><a href="#TypeParser.infer_series">infer_series()</a></code>, <code><a href="#TypeParser.infer_table">infer_table()</a></code>), and does not affect methods where the type is explicitly specified (<code><a href="#TypeParser.is_float">is_float()</a></code>, <code><a href="#TypeParser.is_decimal">is_decimal()</a></code>, <code><a href="#TypeParser.parse_float">parse_float()</a></code>, <code><a href="#TypeParser.parse_decimal">parse_decimal()</a></code>).</p>

<p><code>list_delimiter</code>
: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead. Note that this setting is unaffected by <code><var>parser</var>.trim</code> and <code><var>parser</var>.case_sensitive</code>, and will always be used verbatim.</p>

<p><code>none_values</code>
: list of strings that represent the value <code>None</code></p>

<p><code>none_case_sensitive</code>
: whether matches against <code>none_values</code> should be made in a case-sensitive manner</p>

<p><code>true_values</code>
: list of strings that represent the bool value <code>True</code></p>

<p><code>false_values</code>
: list of strings that represent the bool value <code>False</code></p>

<p><code>bool_case_sensitive</code>
: whether matches against <code>true_values</code> and <code>false_values</code> should be made in a case-sensitive manner</p>

<p><code>int_case_sensitive</code>
: whether checks for int should be done in a case-sensitive manner. This only applies to values given in scientific notation, where the mantissa and exponent usually are separated by <code>e</code>.</p>

<p><code>inf_values</code>
: list of strings that represent the float or Decimal value of infinity. Each of the strings can also be prepended with a negative sign to represent negative infinity.</p>

<p><code>nan_values</code>
: list of strings that represent a float or Decimal that is NaN (not a number)</p>

<p><code>float_case_sensitive</code>
: whether checks for float or Decimal should be done in a case-sensitive manner. This applies to matches against <code>inf_values</code> and <code>nan_values</code>, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by <code>e</code>.</p>

<p><code>case_sensitive</code>
: whether all matches should be made in a case-sensitive manner. Sets all of <code>none_case_sensitive</code>, <code>bool_case_sensitive</code>, <code>int_case_sensitive</code>, <code>float_case_sensitive</code> to the same value, discarding any individual settings.</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code> if any of the options would lead to ambiguities during parsing</p></div>


                            </div>
                            <div id="TypeParser.is_none" class="classattr">
                                        <input id="TypeParser.is_none-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">is_none</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>


                <label class="view-source-button" for="TypeParser.is_none-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.is_none"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_none-462"><a href="#TypeParser.is_none-462"><span class="linenos">462</span></a>	<span class="k">def</span> <span class="nf">is_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.is_none-463"><a href="#TypeParser.is_none-463"><span class="linenos">463</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_none-464"><a href="#TypeParser.is_none-464"><span class="linenos">464</span></a><span class="sd">			Check if a string represents the value None</span>
</span><span id="TypeParser.is_none-465"><a href="#TypeParser.is_none-465"><span class="linenos">465</span></a>
</span><span id="TypeParser.is_none-466"><a href="#TypeParser.is_none-466"><span class="linenos">466</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_values&lt;/code&gt; will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.is_none-467"><a href="#TypeParser.is_none-467"><span class="linenos">467</span></a>
</span><span id="TypeParser.is_none-468"><a href="#TypeParser.is_none-468"><span class="linenos">468</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.is_none-469"><a href="#TypeParser.is_none-469"><span class="linenos">469</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.is_none-470"><a href="#TypeParser.is_none-470"><span class="linenos">470</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.is_none-471"><a href="#TypeParser.is_none-471"><span class="linenos">471</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser.is_none-472"><a href="#TypeParser.is_none-472"><span class="linenos">472</span></a>
</span><span id="TypeParser.is_none-473"><a href="#TypeParser.is_none-473"><span class="linenos">473</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.is_none-474"><a href="#TypeParser.is_none-474"><span class="linenos">474</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.is_none-475"><a href="#TypeParser.is_none-475"><span class="linenos">475</span></a><span class="sd">			whether it is None</span>
</span><span id="TypeParser.is_none-476"><a href="#TypeParser.is_none-476"><span class="linenos">476</span></a>
</span><span id="TypeParser.is_none-477"><a href="#TypeParser.is_none-477"><span class="linenos">477</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.is_none-478"><a href="#TypeParser.is_none-478"><span class="linenos">478</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.is_none-479"><a href="#TypeParser.is_none-479"><span class="linenos">479</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.is_none-480"><a href="#TypeParser.is_none-480"><span class="linenos">480</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.is_none-481"><a href="#TypeParser.is_none-481"><span class="linenos">481</span></a><span class="sd">			parser.is_none(&quot;&quot;)     # True</span>
</span><span id="TypeParser.is_none-482"><a href="#TypeParser.is_none-482"><span class="linenos">482</span></a><span class="sd">			parser.is_none(&quot;abc&quot;)  # False</span>
</span><span id="TypeParser.is_none-483"><a href="#TypeParser.is_none-483"><span class="linenos">483</span></a><span class="sd">			```</span>
</span><span id="TypeParser.is_none-484"><a href="#TypeParser.is_none-484"><span class="linenos">484</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_none-485"><a href="#TypeParser.is_none-485"><span class="linenos">485</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.is_none-486"><a href="#TypeParser.is_none-486"><span class="linenos">486</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.is_none-487"><a href="#TypeParser.is_none-487"><span class="linenos">487</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser.is_none-488"><a href="#TypeParser.is_none-488"><span class="linenos">488</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser.is_none-489"><a href="#TypeParser.is_none-489"><span class="linenos">489</span></a>
</span><span id="TypeParser.is_none-490"><a href="#TypeParser.is_none-490"><span class="linenos">490</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_none_values</span><span class="p">:</span>
</span><span id="TypeParser.is_none-491"><a href="#TypeParser.is_none-491"><span class="linenos">491</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser.is_none-492"><a href="#TypeParser.is_none-492"><span class="linenos">492</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.is_none-493"><a href="#TypeParser.is_none-493"><span class="linenos">493</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span></pre></div>


    <div class="docstring">
<p>Check if a string represents the value None</p>

<p>Only strings that match the values in <code><var>parser</var>.none_values</code> will be interpreted as None. The default accepted values are <code>[""]</code>, i.e. an empty string. The case sensitivity of this matching depends on <code><var>parser</var>.none_case_sensitive</code>, which is False by default.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be checked</p>

<h2 id="returns">Returns</h2>

<p>whether it is None</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>     <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>  <span class="c1"># False</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.is_bool" class="classattr">
                                        <input id="TypeParser.is_bool-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">is_bool</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>


                <label class="view-source-button" for="TypeParser.is_bool-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.is_bool"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_bool-496"><a href="#TypeParser.is_bool-496"><span class="linenos">496</span></a>	<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.is_bool-497"><a href="#TypeParser.is_bool-497"><span class="linenos">497</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_bool-498"><a href="#TypeParser.is_bool-498"><span class="linenos">498</span></a><span class="sd">			Check if a string represents a bool</span>
</span><span id="TypeParser.is_bool-499"><a href="#TypeParser.is_bool-499"><span class="linenos">499</span></a>
</span><span id="TypeParser.is_bool-500"><a href="#TypeParser.is_bool-500"><span class="linenos">500</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.true_values&lt;/code&gt; and &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.false_values&lt;/code&gt; will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.bool_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.is_bool-501"><a href="#TypeParser.is_bool-501"><span class="linenos">501</span></a>
</span><span id="TypeParser.is_bool-502"><a href="#TypeParser.is_bool-502"><span class="linenos">502</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.is_bool-503"><a href="#TypeParser.is_bool-503"><span class="linenos">503</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.is_bool-504"><a href="#TypeParser.is_bool-504"><span class="linenos">504</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.is_bool-505"><a href="#TypeParser.is_bool-505"><span class="linenos">505</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser.is_bool-506"><a href="#TypeParser.is_bool-506"><span class="linenos">506</span></a>
</span><span id="TypeParser.is_bool-507"><a href="#TypeParser.is_bool-507"><span class="linenos">507</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.is_bool-508"><a href="#TypeParser.is_bool-508"><span class="linenos">508</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.is_bool-509"><a href="#TypeParser.is_bool-509"><span class="linenos">509</span></a><span class="sd">			whether it is a bool</span>
</span><span id="TypeParser.is_bool-510"><a href="#TypeParser.is_bool-510"><span class="linenos">510</span></a>
</span><span id="TypeParser.is_bool-511"><a href="#TypeParser.is_bool-511"><span class="linenos">511</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.is_bool-512"><a href="#TypeParser.is_bool-512"><span class="linenos">512</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.is_bool-513"><a href="#TypeParser.is_bool-513"><span class="linenos">513</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.is_bool-514"><a href="#TypeParser.is_bool-514"><span class="linenos">514</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.is_bool-515"><a href="#TypeParser.is_bool-515"><span class="linenos">515</span></a><span class="sd">			parser.is_bool(&quot;true&quot;)  # True</span>
</span><span id="TypeParser.is_bool-516"><a href="#TypeParser.is_bool-516"><span class="linenos">516</span></a><span class="sd">			parser.is_bool(&quot;&quot;)      # True</span>
</span><span id="TypeParser.is_bool-517"><a href="#TypeParser.is_bool-517"><span class="linenos">517</span></a><span class="sd">			parser.is_bool(&quot;abc&quot;)   # False</span>
</span><span id="TypeParser.is_bool-518"><a href="#TypeParser.is_bool-518"><span class="linenos">518</span></a><span class="sd">			```</span>
</span><span id="TypeParser.is_bool-519"><a href="#TypeParser.is_bool-519"><span class="linenos">519</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_bool-520"><a href="#TypeParser.is_bool-520"><span class="linenos">520</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.is_bool-521"><a href="#TypeParser.is_bool-521"><span class="linenos">521</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.is_bool-522"><a href="#TypeParser.is_bool-522"><span class="linenos">522</span></a>
</span><span id="TypeParser.is_bool-523"><a href="#TypeParser.is_bool-523"><span class="linenos">523</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser.is_bool-524"><a href="#TypeParser.is_bool-524"><span class="linenos">524</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser.is_bool-525"><a href="#TypeParser.is_bool-525"><span class="linenos">525</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">:</span>
</span><span id="TypeParser.is_bool-526"><a href="#TypeParser.is_bool-526"><span class="linenos">526</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser.is_bool-527"><a href="#TypeParser.is_bool-527"><span class="linenos">527</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">:</span>
</span><span id="TypeParser.is_bool-528"><a href="#TypeParser.is_bool-528"><span class="linenos">528</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser.is_bool-529"><a href="#TypeParser.is_bool-529"><span class="linenos">529</span></a>
</span><span id="TypeParser.is_bool-530"><a href="#TypeParser.is_bool-530"><span class="linenos">530</span></a>		<span class="k">return</span> <span class="kc">False</span>
</span></pre></div>


    <div class="docstring">
<p>Check if a string represents a bool</p>

<p>Only strings that match the values in <code><var>parser</var>.true_values</code> and <code><var>parser</var>.false_values</code> will be interpreted as booleans. The default accepted values are <code>["true"]</code> and <code>["false"]</code> respectively. The case sensitivity of this matching depends on <code><var>parser</var>.bool_case_sensitive</code>, which is False by default.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be checked</p>

<h2 id="returns">Returns</h2>

<p>whether it is a bool</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>      <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>   <span class="c1"># False</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.is_int" class="classattr">
                                        <input id="TypeParser.is_int-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">is_int</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>


                <label class="view-source-button" for="TypeParser.is_int-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.is_int"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_int-533"><a href="#TypeParser.is_int-533"><span class="linenos">533</span></a>	<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.is_int-534"><a href="#TypeParser.is_int-534"><span class="linenos">534</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_int-535"><a href="#TypeParser.is_int-535"><span class="linenos">535</span></a><span class="sd">			Check if a string represents an int</span>
</span><span id="TypeParser.is_int-536"><a href="#TypeParser.is_int-536"><span class="linenos">536</span></a>
</span><span id="TypeParser.is_int-537"><a href="#TypeParser.is_int-537"><span class="linenos">537</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.is_int-538"><a href="#TypeParser.is_int-538"><span class="linenos">538</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.is_int-539"><a href="#TypeParser.is_int-539"><span class="linenos">539</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.is_int-540"><a href="#TypeParser.is_int-540"><span class="linenos">540</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser.is_int-541"><a href="#TypeParser.is_int-541"><span class="linenos">541</span></a>
</span><span id="TypeParser.is_int-542"><a href="#TypeParser.is_int-542"><span class="linenos">542</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser.is_int-543"><a href="#TypeParser.is_int-543"><span class="linenos">543</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser.is_int-544"><a href="#TypeParser.is_int-544"><span class="linenos">544</span></a>
</span><span id="TypeParser.is_int-545"><a href="#TypeParser.is_int-545"><span class="linenos">545</span></a><span class="sd">			`allow_negative`</span>
</span><span id="TypeParser.is_int-546"><a href="#TypeParser.is_int-546"><span class="linenos">546</span></a><span class="sd">			: whether to accept negative values. Since negative values are always indicated with a negative sign, `allow_sign` must also be True (which is the default setting) for this to have any effect.</span>
</span><span id="TypeParser.is_int-547"><a href="#TypeParser.is_int-547"><span class="linenos">547</span></a>
</span><span id="TypeParser.is_int-548"><a href="#TypeParser.is_int-548"><span class="linenos">548</span></a><span class="sd">			`allow_sign`</span>
</span><span id="TypeParser.is_int-549"><a href="#TypeParser.is_int-549"><span class="linenos">549</span></a><span class="sd">			: whether to accept values prepended with a sign character. If False, it implies that `allow_negative` is False also.</span>
</span><span id="TypeParser.is_int-550"><a href="#TypeParser.is_int-550"><span class="linenos">550</span></a>
</span><span id="TypeParser.is_int-551"><a href="#TypeParser.is_int-551"><span class="linenos">551</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser.is_int-552"><a href="#TypeParser.is_int-552"><span class="linenos">552</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;M&lt;/var&gt; must be an integer and &lt;var&gt;X&lt;/var&gt; must be a non-negative integer, even in cases where the expression would evaluate mathematically to an integer.</span>
</span><span id="TypeParser.is_int-553"><a href="#TypeParser.is_int-553"><span class="linenos">553</span></a>
</span><span id="TypeParser.is_int-554"><a href="#TypeParser.is_int-554"><span class="linenos">554</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.is_int-555"><a href="#TypeParser.is_int-555"><span class="linenos">555</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.is_int-556"><a href="#TypeParser.is_int-556"><span class="linenos">556</span></a><span class="sd">			whether it is an int</span>
</span><span id="TypeParser.is_int-557"><a href="#TypeParser.is_int-557"><span class="linenos">557</span></a>
</span><span id="TypeParser.is_int-558"><a href="#TypeParser.is_int-558"><span class="linenos">558</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.is_int-559"><a href="#TypeParser.is_int-559"><span class="linenos">559</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.is_int-560"><a href="#TypeParser.is_int-560"><span class="linenos">560</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.is_int-561"><a href="#TypeParser.is_int-561"><span class="linenos">561</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.is_int-562"><a href="#TypeParser.is_int-562"><span class="linenos">562</span></a><span class="sd">			parser.is_int(&quot;0&quot;)    # True</span>
</span><span id="TypeParser.is_int-563"><a href="#TypeParser.is_int-563"><span class="linenos">563</span></a><span class="sd">			parser.is_int(&quot;-1&quot;)   # True</span>
</span><span id="TypeParser.is_int-564"><a href="#TypeParser.is_int-564"><span class="linenos">564</span></a><span class="sd">			parser.is_int(&quot;abc&quot;)  # False</span>
</span><span id="TypeParser.is_int-565"><a href="#TypeParser.is_int-565"><span class="linenos">565</span></a><span class="sd">			parser.is_int(&quot;&quot;)     # False</span>
</span><span id="TypeParser.is_int-566"><a href="#TypeParser.is_int-566"><span class="linenos">566</span></a><span class="sd">			```</span>
</span><span id="TypeParser.is_int-567"><a href="#TypeParser.is_int-567"><span class="linenos">567</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_int-568"><a href="#TypeParser.is_int-568"><span class="linenos">568</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.is_int-569"><a href="#TypeParser.is_int-569"><span class="linenos">569</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.is_int-570"><a href="#TypeParser.is_int-570"><span class="linenos">570</span></a>
</span><span id="TypeParser.is_int-571"><a href="#TypeParser.is_int-571"><span class="linenos">571</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="TypeParser.is_int-572"><a href="#TypeParser.is_int-572"><span class="linenos">572</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-573"><a href="#TypeParser.is_int-573"><span class="linenos">573</span></a>
</span><span id="TypeParser.is_int-574"><a href="#TypeParser.is_int-574"><span class="linenos">574</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
</span><span id="TypeParser.is_int-575"><a href="#TypeParser.is_int-575"><span class="linenos">575</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser.is_int-576"><a href="#TypeParser.is_int-576"><span class="linenos">576</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser.is_int-577"><a href="#TypeParser.is_int-577"><span class="linenos">577</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
</span><span id="TypeParser.is_int-578"><a href="#TypeParser.is_int-578"><span class="linenos">578</span></a>					<span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
</span><span id="TypeParser.is_int-579"><a href="#TypeParser.is_int-579"><span class="linenos">579</span></a>				<span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
</span><span id="TypeParser.is_int-580"><a href="#TypeParser.is_int-580"><span class="linenos">580</span></a>					<span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
</span><span id="TypeParser.is_int-581"><a href="#TypeParser.is_int-581"><span class="linenos">581</span></a>				<span class="p">)</span>
</span><span id="TypeParser.is_int-582"><a href="#TypeParser.is_int-582"><span class="linenos">582</span></a>
</span><span id="TypeParser.is_int-583"><a href="#TypeParser.is_int-583"><span class="linenos">583</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
</span><span id="TypeParser.is_int-584"><a href="#TypeParser.is_int-584"><span class="linenos">584</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span id="TypeParser.is_int-585"><a href="#TypeParser.is_int-585"><span class="linenos">585</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-586"><a href="#TypeParser.is_int-586"><span class="linenos">586</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sign</span><span class="p">:</span>
</span><span id="TypeParser.is_int-587"><a href="#TypeParser.is_int-587"><span class="linenos">587</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-588"><a href="#TypeParser.is_int-588"><span class="linenos">588</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_negative</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
</span><span id="TypeParser.is_int-589"><a href="#TypeParser.is_int-589"><span class="linenos">589</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-590"><a href="#TypeParser.is_int-590"><span class="linenos">590</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser.is_int-591"><a href="#TypeParser.is_int-591"><span class="linenos">591</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
</span><span id="TypeParser.is_int-592"><a href="#TypeParser.is_int-592"><span class="linenos">592</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-593"><a href="#TypeParser.is_int-593"><span class="linenos">593</span></a>
</span><span id="TypeParser.is_int-594"><a href="#TypeParser.is_int-594"><span class="linenos">594</span></a>		<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-595"><a href="#TypeParser.is_int-595"><span class="linenos">595</span></a>		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
</span><span id="TypeParser.is_int-596"><a href="#TypeParser.is_int-596"><span class="linenos">596</span></a>			<span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
</span><span id="TypeParser.is_int-597"><a href="#TypeParser.is_int-597"><span class="linenos">597</span></a>				<span class="k">if</span> <span class="n">prev_separated</span><span class="p">:</span>
</span><span id="TypeParser.is_int-598"><a href="#TypeParser.is_int-598"><span class="linenos">598</span></a>					<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-599"><a href="#TypeParser.is_int-599"><span class="linenos">599</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="TypeParser.is_int-600"><a href="#TypeParser.is_int-600"><span class="linenos">600</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.is_int-601"><a href="#TypeParser.is_int-601"><span class="linenos">601</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-602"><a href="#TypeParser.is_int-602"><span class="linenos">602</span></a>				<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span><span class="p">:</span>
</span><span id="TypeParser.is_int-603"><a href="#TypeParser.is_int-603"><span class="linenos">603</span></a>					<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_int-604"><a href="#TypeParser.is_int-604"><span class="linenos">604</span></a>		<span class="k">return</span> <span class="kc">True</span>
</span></pre></div>


    <div class="docstring">
<p>Check if a string represents an int</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be checked</p>

<h2 id="keyword-arguments">Keyword arguments</h2>

<p><code>allow_negative</code>
: whether to accept negative values. Since negative values are always indicated with a negative sign, <code>allow_sign</code> must also be True (which is the default setting) for this to have any effect.</p>

<p><code>allow_sign</code>
: whether to accept values prepended with a sign character. If False, it implies that <code>allow_negative</code> is False also.</p>

<p><code>allow_scientific</code>
: whether to accept scientific notation. If True, strings of the form <code>"<var>M</var>e<var>X</var>"</code> will be interpreted as the expression <code><var>M</var> * (10 ** <var>X</var>)</code>, where <var>M</var> is the mantissa/significand and <var>X</var> is the exponent. Note that <var>M</var> must be an integer and <var>X</var> must be a non-negative integer, even in cases where the expression would evaluate mathematically to an integer.</p>

<h2 id="returns">Returns</h2>

<p>whether it is an int</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">)</span>    <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="s2">&quot;-1&quot;</span><span class="p">)</span>   <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>  <span class="c1"># False</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>     <span class="c1"># False</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.is_float" class="classattr">
                                        <input id="TypeParser.is_float-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">is_float</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>


                <label class="view-source-button" for="TypeParser.is_float-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.is_float"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_float-607"><a href="#TypeParser.is_float-607"><span class="linenos">607</span></a>	<span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.is_float-608"><a href="#TypeParser.is_float-608"><span class="linenos">608</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_float-609"><a href="#TypeParser.is_float-609"><span class="linenos">609</span></a><span class="sd">			Check if a string represents a float (or equivalently, a Decimal)</span>
</span><span id="TypeParser.is_float-610"><a href="#TypeParser.is_float-610"><span class="linenos">610</span></a>
</span><span id="TypeParser.is_float-611"><a href="#TypeParser.is_float-611"><span class="linenos">611</span></a><span class="sd">			This function will also return True if the string represents an int.</span>
</span><span id="TypeParser.is_float-612"><a href="#TypeParser.is_float-612"><span class="linenos">612</span></a>
</span><span id="TypeParser.is_float-613"><a href="#TypeParser.is_float-613"><span class="linenos">613</span></a><span class="sd">			Alias: `is_decimal()`</span>
</span><span id="TypeParser.is_float-614"><a href="#TypeParser.is_float-614"><span class="linenos">614</span></a>
</span><span id="TypeParser.is_float-615"><a href="#TypeParser.is_float-615"><span class="linenos">615</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.is_float-616"><a href="#TypeParser.is_float-616"><span class="linenos">616</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.is_float-617"><a href="#TypeParser.is_float-617"><span class="linenos">617</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.is_float-618"><a href="#TypeParser.is_float-618"><span class="linenos">618</span></a><span class="sd">			: string to be checked</span>
</span><span id="TypeParser.is_float-619"><a href="#TypeParser.is_float-619"><span class="linenos">619</span></a>
</span><span id="TypeParser.is_float-620"><a href="#TypeParser.is_float-620"><span class="linenos">620</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser.is_float-621"><a href="#TypeParser.is_float-621"><span class="linenos">621</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser.is_float-622"><a href="#TypeParser.is_float-622"><span class="linenos">622</span></a>
</span><span id="TypeParser.is_float-623"><a href="#TypeParser.is_float-623"><span class="linenos">623</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser.is_float-624"><a href="#TypeParser.is_float-624"><span class="linenos">624</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
</span><span id="TypeParser.is_float-625"><a href="#TypeParser.is_float-625"><span class="linenos">625</span></a>
</span><span id="TypeParser.is_float-626"><a href="#TypeParser.is_float-626"><span class="linenos">626</span></a><span class="sd">			`allow_inf`</span>
</span><span id="TypeParser.is_float-627"><a href="#TypeParser.is_float-627"><span class="linenos">627</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.inf_values&lt;/code&gt; (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.is_float-628"><a href="#TypeParser.is_float-628"><span class="linenos">628</span></a>
</span><span id="TypeParser.is_float-629"><a href="#TypeParser.is_float-629"><span class="linenos">629</span></a><span class="sd">			`allow_nan`</span>
</span><span id="TypeParser.is_float-630"><a href="#TypeParser.is_float-630"><span class="linenos">630</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.nan_values&lt;/code&gt; (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.is_float-631"><a href="#TypeParser.is_float-631"><span class="linenos">631</span></a>
</span><span id="TypeParser.is_float-632"><a href="#TypeParser.is_float-632"><span class="linenos">632</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.is_float-633"><a href="#TypeParser.is_float-633"><span class="linenos">633</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.is_float-634"><a href="#TypeParser.is_float-634"><span class="linenos">634</span></a><span class="sd">			whether it is a float or Decimal</span>
</span><span id="TypeParser.is_float-635"><a href="#TypeParser.is_float-635"><span class="linenos">635</span></a>
</span><span id="TypeParser.is_float-636"><a href="#TypeParser.is_float-636"><span class="linenos">636</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.is_float-637"><a href="#TypeParser.is_float-637"><span class="linenos">637</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.is_float-638"><a href="#TypeParser.is_float-638"><span class="linenos">638</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.is_float-639"><a href="#TypeParser.is_float-639"><span class="linenos">639</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.is_float-640"><a href="#TypeParser.is_float-640"><span class="linenos">640</span></a><span class="sd">			parser.is_float(&quot;1.&quot;)       # True</span>
</span><span id="TypeParser.is_float-641"><a href="#TypeParser.is_float-641"><span class="linenos">641</span></a><span class="sd">			parser.is_float(&quot;12.3e-2&quot;)  # True</span>
</span><span id="TypeParser.is_float-642"><a href="#TypeParser.is_float-642"><span class="linenos">642</span></a><span class="sd">			parser.is_float(&quot;abc&quot;)      # False</span>
</span><span id="TypeParser.is_float-643"><a href="#TypeParser.is_float-643"><span class="linenos">643</span></a><span class="sd">			parser.is_float(&quot;&quot;)         # False</span>
</span><span id="TypeParser.is_float-644"><a href="#TypeParser.is_float-644"><span class="linenos">644</span></a><span class="sd">			```</span>
</span><span id="TypeParser.is_float-645"><a href="#TypeParser.is_float-645"><span class="linenos">645</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_float-646"><a href="#TypeParser.is_float-646"><span class="linenos">646</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.is_float-647"><a href="#TypeParser.is_float-647"><span class="linenos">647</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.is_float-648"><a href="#TypeParser.is_float-648"><span class="linenos">648</span></a>
</span><span id="TypeParser.is_float-649"><a href="#TypeParser.is_float-649"><span class="linenos">649</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
</span><span id="TypeParser.is_float-650"><a href="#TypeParser.is_float-650"><span class="linenos">650</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser.is_float-651"><a href="#TypeParser.is_float-651"><span class="linenos">651</span></a>
</span><span id="TypeParser.is_float-652"><a href="#TypeParser.is_float-652"><span class="linenos">652</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser.is_float-653"><a href="#TypeParser.is_float-653"><span class="linenos">653</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser.is_float-654"><a href="#TypeParser.is_float-654"><span class="linenos">654</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.is_float-655"><a href="#TypeParser.is_float-655"><span class="linenos">655</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser.is_float-656"><a href="#TypeParser.is_float-656"><span class="linenos">656</span></a>		<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_inf_values</span><span class="p">:</span>
</span><span id="TypeParser.is_float-657"><a href="#TypeParser.is_float-657"><span class="linenos">657</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser.is_float-658"><a href="#TypeParser.is_float-658"><span class="linenos">658</span></a>		<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_nan_values</span><span class="p">:</span>
</span><span id="TypeParser.is_float-659"><a href="#TypeParser.is_float-659"><span class="linenos">659</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser.is_float-660"><a href="#TypeParser.is_float-660"><span class="linenos">660</span></a>
</span><span id="TypeParser.is_float-661"><a href="#TypeParser.is_float-661"><span class="linenos">661</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="TypeParser.is_float-662"><a href="#TypeParser.is_float-662"><span class="linenos">662</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_float-663"><a href="#TypeParser.is_float-663"><span class="linenos">663</span></a>
</span><span id="TypeParser.is_float-664"><a href="#TypeParser.is_float-664"><span class="linenos">664</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
</span><span id="TypeParser.is_float-665"><a href="#TypeParser.is_float-665"><span class="linenos">665</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser.is_float-666"><a href="#TypeParser.is_float-666"><span class="linenos">666</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser.is_float-667"><a href="#TypeParser.is_float-667"><span class="linenos">667</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="TypeParser.is_float-668"><a href="#TypeParser.is_float-668"><span class="linenos">668</span></a>
</span><span id="TypeParser.is_float-669"><a href="#TypeParser.is_float-669"><span class="linenos">669</span></a>		<span class="n">value</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser.is_float-670"><a href="#TypeParser.is_float-670"><span class="linenos">670</span></a>		<span class="k">if</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser.is_float-671"><a href="#TypeParser.is_float-671"><span class="linenos">671</span></a>			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
</span><span id="TypeParser.is_float-672"><a href="#TypeParser.is_float-672"><span class="linenos">672</span></a>				<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.is_float-673"><a href="#TypeParser.is_float-673"><span class="linenos">673</span></a>			<span class="k">return</span> <span class="p">(</span>
</span><span id="TypeParser.is_float-674"><a href="#TypeParser.is_float-674"><span class="linenos">674</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
</span><span id="TypeParser.is_float-675"><a href="#TypeParser.is_float-675"><span class="linenos">675</span></a>			<span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
</span><span id="TypeParser.is_float-676"><a href="#TypeParser.is_float-676"><span class="linenos">676</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
</span><span id="TypeParser.is_float-677"><a href="#TypeParser.is_float-677"><span class="linenos">677</span></a>			<span class="p">)</span>
</span><span id="TypeParser.is_float-678"><a href="#TypeParser.is_float-678"><span class="linenos">678</span></a>
</span><span id="TypeParser.is_float-679"><a href="#TypeParser.is_float-679"><span class="linenos">679</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Check if a string represents a float (or equivalently, a Decimal)</p>

<p>This function will also return True if the string represents an int.</p>

<p>Alias: <code><a href="#TypeParser.is_decimal">is_decimal()</a></code></p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be checked</p>

<h2 id="keyword-arguments">Keyword arguments</h2>

<p><code>allow_scientific</code>
: whether to accept scientific notation. If True, strings of the form <code>"<var>M</var>e<var>X</var>"</code> will be interpreted as the expression <code><var>M</var> * (10 ** <var>X</var>)</code>, where <var>M</var> is the mantissa/significand and <var>X</var> is the exponent. Note that <var>X</var> must be an integer, but can be negative.</p>

<p><code>allow_inf</code>
: whether to accept positive and negative infinity values. If True, strings that match the values in <code><var>parser</var>.inf_values</code> (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on <code><var>parser</var>.float_case_sensitive</code>, which is False by default.</p>

<p><code>allow_nan</code>
: whether to accept NaN (not a number) representations. If True, strings that match the values in <code><var>parser</var>.nan_values</code> (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on <code><var>parser</var>.float_case_sensitive</code>, which is False by default.</p>

<h2 id="returns">Returns</h2>

<p>whether it is a float or Decimal</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="s2">&quot;1.&quot;</span><span class="p">)</span>       <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="s2">&quot;12.3e-2&quot;</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>      <span class="c1"># False</span>
<span class="n">parser</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>         <span class="c1"># False</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.is_decimal" class="classattr">
                                        <input id="TypeParser.is_decimal-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">is_decimal</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>


                <label class="view-source-button" for="TypeParser.is_decimal-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.is_decimal"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_decimal-682"><a href="#TypeParser.is_decimal-682"><span class="linenos">682</span></a>	<span class="k">def</span> <span class="nf">is_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.is_decimal-683"><a href="#TypeParser.is_decimal-683"><span class="linenos">683</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_decimal-684"><a href="#TypeParser.is_decimal-684"><span class="linenos">684</span></a><span class="sd">			Alias of `is_float()`</span>
</span><span id="TypeParser.is_decimal-685"><a href="#TypeParser.is_decimal-685"><span class="linenos">685</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.is_decimal-686"><a href="#TypeParser.is_decimal-686"><span class="linenos">686</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Alias of <code><a href="#TypeParser.is_float">is_float()</a></code></p></div>


                            </div>
                            <div id="TypeParser.parse_none" class="classattr">
                                        <input id="TypeParser.parse_none-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_none</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="kc">None</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_none-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_none"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_none-689"><a href="#TypeParser.parse_none-689"><span class="linenos">689</span></a>	<span class="k">def</span> <span class="nf">parse_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser.parse_none-690"><a href="#TypeParser.parse_none-690"><span class="linenos">690</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_none-691"><a href="#TypeParser.parse_none-691"><span class="linenos">691</span></a><span class="sd">			Parse a string and return it as the value None if possible</span>
</span><span id="TypeParser.parse_none-692"><a href="#TypeParser.parse_none-692"><span class="linenos">692</span></a>
</span><span id="TypeParser.parse_none-693"><a href="#TypeParser.parse_none-693"><span class="linenos">693</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_values&lt;/code&gt; will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.none_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.parse_none-694"><a href="#TypeParser.parse_none-694"><span class="linenos">694</span></a>
</span><span id="TypeParser.parse_none-695"><a href="#TypeParser.parse_none-695"><span class="linenos">695</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_none-696"><a href="#TypeParser.parse_none-696"><span class="linenos">696</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_none-697"><a href="#TypeParser.parse_none-697"><span class="linenos">697</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.parse_none-698"><a href="#TypeParser.parse_none-698"><span class="linenos">698</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser.parse_none-699"><a href="#TypeParser.parse_none-699"><span class="linenos">699</span></a>
</span><span id="TypeParser.parse_none-700"><a href="#TypeParser.parse_none-700"><span class="linenos">700</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_none-701"><a href="#TypeParser.parse_none-701"><span class="linenos">701</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_none-702"><a href="#TypeParser.parse_none-702"><span class="linenos">702</span></a><span class="sd">			parsed None value</span>
</span><span id="TypeParser.parse_none-703"><a href="#TypeParser.parse_none-703"><span class="linenos">703</span></a>
</span><span id="TypeParser.parse_none-704"><a href="#TypeParser.parse_none-704"><span class="linenos">704</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.parse_none-705"><a href="#TypeParser.parse_none-705"><span class="linenos">705</span></a><span class="sd">			------</span>
</span><span id="TypeParser.parse_none-706"><a href="#TypeParser.parse_none-706"><span class="linenos">706</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser.parse_none-707"><a href="#TypeParser.parse_none-707"><span class="linenos">707</span></a>
</span><span id="TypeParser.parse_none-708"><a href="#TypeParser.parse_none-708"><span class="linenos">708</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_none-709"><a href="#TypeParser.parse_none-709"><span class="linenos">709</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_none-710"><a href="#TypeParser.parse_none-710"><span class="linenos">710</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_none-711"><a href="#TypeParser.parse_none-711"><span class="linenos">711</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.parse_none-712"><a href="#TypeParser.parse_none-712"><span class="linenos">712</span></a><span class="sd">			parser.parse_none(&quot;&quot;)     # None</span>
</span><span id="TypeParser.parse_none-713"><a href="#TypeParser.parse_none-713"><span class="linenos">713</span></a><span class="sd">			parser.parse_none(&quot;abc&quot;)  # raises ValueError</span>
</span><span id="TypeParser.parse_none-714"><a href="#TypeParser.parse_none-714"><span class="linenos">714</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_none-715"><a href="#TypeParser.parse_none-715"><span class="linenos">715</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_none-716"><a href="#TypeParser.parse_none-716"><span class="linenos">716</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.parse_none-717"><a href="#TypeParser.parse_none-717"><span class="linenos">717</span></a>			<span class="k">return</span> <span class="kc">None</span>
</span><span id="TypeParser.parse_none-718"><a href="#TypeParser.parse_none-718"><span class="linenos">718</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.parse_none-719"><a href="#TypeParser.parse_none-719"><span class="linenos">719</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a none value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a string and return it as the value None if possible</p>

<p>Only strings that match the values in <code><var>parser</var>.none_values</code> will be interpreted as None. The default accepted values are <code>[""]</code>, i.e. an empty string. The case sensitivity of this matching depends on <code><var>parser</var>.none_case_sensitive</code>, which is False by default.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be parsed</p>

<h2 id="returns">Returns</h2>

<p>parsed None value</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code> if <code>value</code> cannot be parsed</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_none</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>     <span class="c1"># None</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_none</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>  <span class="c1"># raises ValueError</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse_bool" class="classattr">
                                        <input id="TypeParser.parse_bool-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_bool</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_bool-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_bool"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_bool-722"><a href="#TypeParser.parse_bool-722"><span class="linenos">722</span></a>	<span class="k">def</span> <span class="nf">parse_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.parse_bool-723"><a href="#TypeParser.parse_bool-723"><span class="linenos">723</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_bool-724"><a href="#TypeParser.parse_bool-724"><span class="linenos">724</span></a><span class="sd">			Parse a string and return it as a bool if possible</span>
</span><span id="TypeParser.parse_bool-725"><a href="#TypeParser.parse_bool-725"><span class="linenos">725</span></a>
</span><span id="TypeParser.parse_bool-726"><a href="#TypeParser.parse_bool-726"><span class="linenos">726</span></a><span class="sd">			Only strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.true_values&lt;/code&gt; and &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.false_values&lt;/code&gt; will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.bool_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.parse_bool-727"><a href="#TypeParser.parse_bool-727"><span class="linenos">727</span></a>
</span><span id="TypeParser.parse_bool-728"><a href="#TypeParser.parse_bool-728"><span class="linenos">728</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_bool-729"><a href="#TypeParser.parse_bool-729"><span class="linenos">729</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_bool-730"><a href="#TypeParser.parse_bool-730"><span class="linenos">730</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.parse_bool-731"><a href="#TypeParser.parse_bool-731"><span class="linenos">731</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser.parse_bool-732"><a href="#TypeParser.parse_bool-732"><span class="linenos">732</span></a>
</span><span id="TypeParser.parse_bool-733"><a href="#TypeParser.parse_bool-733"><span class="linenos">733</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_bool-734"><a href="#TypeParser.parse_bool-734"><span class="linenos">734</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_bool-735"><a href="#TypeParser.parse_bool-735"><span class="linenos">735</span></a><span class="sd">			parsed bool value</span>
</span><span id="TypeParser.parse_bool-736"><a href="#TypeParser.parse_bool-736"><span class="linenos">736</span></a>
</span><span id="TypeParser.parse_bool-737"><a href="#TypeParser.parse_bool-737"><span class="linenos">737</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.parse_bool-738"><a href="#TypeParser.parse_bool-738"><span class="linenos">738</span></a><span class="sd">			------</span>
</span><span id="TypeParser.parse_bool-739"><a href="#TypeParser.parse_bool-739"><span class="linenos">739</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser.parse_bool-740"><a href="#TypeParser.parse_bool-740"><span class="linenos">740</span></a>
</span><span id="TypeParser.parse_bool-741"><a href="#TypeParser.parse_bool-741"><span class="linenos">741</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_bool-742"><a href="#TypeParser.parse_bool-742"><span class="linenos">742</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_bool-743"><a href="#TypeParser.parse_bool-743"><span class="linenos">743</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_bool-744"><a href="#TypeParser.parse_bool-744"><span class="linenos">744</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.parse_bool-745"><a href="#TypeParser.parse_bool-745"><span class="linenos">745</span></a><span class="sd">			parser.parse_bool(&quot;true&quot;)   # True</span>
</span><span id="TypeParser.parse_bool-746"><a href="#TypeParser.parse_bool-746"><span class="linenos">746</span></a><span class="sd">			parser.parse_bool(&quot;FALSE&quot;)  # False</span>
</span><span id="TypeParser.parse_bool-747"><a href="#TypeParser.parse_bool-747"><span class="linenos">747</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_bool-748"><a href="#TypeParser.parse_bool-748"><span class="linenos">748</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_bool-749"><a href="#TypeParser.parse_bool-749"><span class="linenos">749</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.parse_bool-750"><a href="#TypeParser.parse_bool-750"><span class="linenos">750</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.parse_bool-751"><a href="#TypeParser.parse_bool-751"><span class="linenos">751</span></a>
</span><span id="TypeParser.parse_bool-752"><a href="#TypeParser.parse_bool-752"><span class="linenos">752</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_case_sensitive</span><span class="p">:</span>
</span><span id="TypeParser.parse_bool-753"><a href="#TypeParser.parse_bool-753"><span class="linenos">753</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="TypeParser.parse_bool-754"><a href="#TypeParser.parse_bool-754"><span class="linenos">754</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.parse_bool-755"><a href="#TypeParser.parse_bool-755"><span class="linenos">755</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span id="TypeParser.parse_bool-756"><a href="#TypeParser.parse_bool-756"><span class="linenos">756</span></a>
</span><span id="TypeParser.parse_bool-757"><a href="#TypeParser.parse_bool-757"><span class="linenos">757</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_true_values</span><span class="p">:</span>
</span><span id="TypeParser.parse_bool-758"><a href="#TypeParser.parse_bool-758"><span class="linenos">758</span></a>			<span class="k">return</span> <span class="kc">True</span>
</span><span id="TypeParser.parse_bool-759"><a href="#TypeParser.parse_bool-759"><span class="linenos">759</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_false_values</span><span class="p">:</span>
</span><span id="TypeParser.parse_bool-760"><a href="#TypeParser.parse_bool-760"><span class="linenos">760</span></a>			<span class="k">return</span> <span class="kc">False</span>
</span><span id="TypeParser.parse_bool-761"><a href="#TypeParser.parse_bool-761"><span class="linenos">761</span></a>
</span><span id="TypeParser.parse_bool-762"><a href="#TypeParser.parse_bool-762"><span class="linenos">762</span></a>		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a boolean: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a string and return it as a bool if possible</p>

<p>Only strings that match the values in <code><var>parser</var>.true_values</code> and <code><var>parser</var>.false_values</code> will be interpreted as booleans. The default accepted values are <code>["true"]</code> and <code>["false"]</code> respectively. The case sensitivity of this matching depends on <code><var>parser</var>.bool_case_sensitive</code>, which is False by default.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be parsed</p>

<h2 id="returns">Returns</h2>

<p>parsed bool value</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code> if <code>value</code> cannot be parsed</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>   <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="s2">&quot;FALSE&quot;</span><span class="p">)</span>  <span class="c1"># False</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse_int" class="classattr">
                                        <input id="TypeParser.parse_int-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_int</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">int</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_int-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_int"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_int-765"><a href="#TypeParser.parse_int-765"><span class="linenos">765</span></a>	<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="TypeParser.parse_int-766"><a href="#TypeParser.parse_int-766"><span class="linenos">766</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_int-767"><a href="#TypeParser.parse_int-767"><span class="linenos">767</span></a><span class="sd">			Parse a string and return it as an int if possible</span>
</span><span id="TypeParser.parse_int-768"><a href="#TypeParser.parse_int-768"><span class="linenos">768</span></a>
</span><span id="TypeParser.parse_int-769"><a href="#TypeParser.parse_int-769"><span class="linenos">769</span></a><span class="sd">			If the string represents a bool, it will be converted to `1` for True and `0` for False.</span>
</span><span id="TypeParser.parse_int-770"><a href="#TypeParser.parse_int-770"><span class="linenos">770</span></a>
</span><span id="TypeParser.parse_int-771"><a href="#TypeParser.parse_int-771"><span class="linenos">771</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_int-772"><a href="#TypeParser.parse_int-772"><span class="linenos">772</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_int-773"><a href="#TypeParser.parse_int-773"><span class="linenos">773</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.parse_int-774"><a href="#TypeParser.parse_int-774"><span class="linenos">774</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser.parse_int-775"><a href="#TypeParser.parse_int-775"><span class="linenos">775</span></a>
</span><span id="TypeParser.parse_int-776"><a href="#TypeParser.parse_int-776"><span class="linenos">776</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser.parse_int-777"><a href="#TypeParser.parse_int-777"><span class="linenos">777</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser.parse_int-778"><a href="#TypeParser.parse_int-778"><span class="linenos">778</span></a>
</span><span id="TypeParser.parse_int-779"><a href="#TypeParser.parse_int-779"><span class="linenos">779</span></a><span class="sd">			`allow_negative`</span>
</span><span id="TypeParser.parse_int-780"><a href="#TypeParser.parse_int-780"><span class="linenos">780</span></a><span class="sd">			: whether to accept negative values. Since negative values are always indicated with a negative sign, `allow_sign` must also be True (which is the default setting) for this to have any effect.</span>
</span><span id="TypeParser.parse_int-781"><a href="#TypeParser.parse_int-781"><span class="linenos">781</span></a>
</span><span id="TypeParser.parse_int-782"><a href="#TypeParser.parse_int-782"><span class="linenos">782</span></a><span class="sd">			`allow_sign`</span>
</span><span id="TypeParser.parse_int-783"><a href="#TypeParser.parse_int-783"><span class="linenos">783</span></a><span class="sd">			: whether to accept values prepended with a sign character. If False, it implies that `allow_negative` is False also.</span>
</span><span id="TypeParser.parse_int-784"><a href="#TypeParser.parse_int-784"><span class="linenos">784</span></a>
</span><span id="TypeParser.parse_int-785"><a href="#TypeParser.parse_int-785"><span class="linenos">785</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser.parse_int-786"><a href="#TypeParser.parse_int-786"><span class="linenos">786</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;M&lt;/var&gt; must be an integer and &lt;var&gt;X&lt;/var&gt; must be a non-negative integer, even in cases where the expression would evaluate mathematically to an integer.</span>
</span><span id="TypeParser.parse_int-787"><a href="#TypeParser.parse_int-787"><span class="linenos">787</span></a>
</span><span id="TypeParser.parse_int-788"><a href="#TypeParser.parse_int-788"><span class="linenos">788</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_int-789"><a href="#TypeParser.parse_int-789"><span class="linenos">789</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_int-790"><a href="#TypeParser.parse_int-790"><span class="linenos">790</span></a><span class="sd">			parsed int value</span>
</span><span id="TypeParser.parse_int-791"><a href="#TypeParser.parse_int-791"><span class="linenos">791</span></a>
</span><span id="TypeParser.parse_int-792"><a href="#TypeParser.parse_int-792"><span class="linenos">792</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.parse_int-793"><a href="#TypeParser.parse_int-793"><span class="linenos">793</span></a><span class="sd">			------</span>
</span><span id="TypeParser.parse_int-794"><a href="#TypeParser.parse_int-794"><span class="linenos">794</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser.parse_int-795"><a href="#TypeParser.parse_int-795"><span class="linenos">795</span></a>
</span><span id="TypeParser.parse_int-796"><a href="#TypeParser.parse_int-796"><span class="linenos">796</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_int-797"><a href="#TypeParser.parse_int-797"><span class="linenos">797</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_int-798"><a href="#TypeParser.parse_int-798"><span class="linenos">798</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_int-799"><a href="#TypeParser.parse_int-799"><span class="linenos">799</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.parse_int-800"><a href="#TypeParser.parse_int-800"><span class="linenos">800</span></a><span class="sd">			parser.parse_int(&quot;0&quot;)    # 0</span>
</span><span id="TypeParser.parse_int-801"><a href="#TypeParser.parse_int-801"><span class="linenos">801</span></a><span class="sd">			parser.parse_int(&quot;-1&quot;)   # -1</span>
</span><span id="TypeParser.parse_int-802"><a href="#TypeParser.parse_int-802"><span class="linenos">802</span></a><span class="sd">			parser.parse_int(&quot;2e3&quot;)  # 2000</span>
</span><span id="TypeParser.parse_int-803"><a href="#TypeParser.parse_int-803"><span class="linenos">803</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_int-804"><a href="#TypeParser.parse_int-804"><span class="linenos">804</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_int-805"><a href="#TypeParser.parse_int-805"><span class="linenos">805</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.parse_int-806"><a href="#TypeParser.parse_int-806"><span class="linenos">806</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.parse_int-807"><a href="#TypeParser.parse_int-807"><span class="linenos">807</span></a>
</span><span id="TypeParser.parse_int-808"><a href="#TypeParser.parse_int-808"><span class="linenos">808</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="n">allow_sign</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">):</span>
</span><span id="TypeParser.parse_int-809"><a href="#TypeParser.parse_int-809"><span class="linenos">809</span></a>			<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
</span><span id="TypeParser.parse_int-810"><a href="#TypeParser.parse_int-810"><span class="linenos">810</span></a>				<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_case_sensitive</span><span class="p">)</span>
</span><span id="TypeParser.parse_int-811"><a href="#TypeParser.parse_int-811"><span class="linenos">811</span></a>				<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser.parse_int-812"><a href="#TypeParser.parse_int-812"><span class="linenos">812</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
</span><span id="TypeParser.parse_int-813"><a href="#TypeParser.parse_int-813"><span class="linenos">813</span></a>						<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser.parse_int-814"><a href="#TypeParser.parse_int-814"><span class="linenos">814</span></a>					<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
</span><span id="TypeParser.parse_int-815"><a href="#TypeParser.parse_int-815"><span class="linenos">815</span></a>
</span><span id="TypeParser.parse_int-816"><a href="#TypeParser.parse_int-816"><span class="linenos">816</span></a>			<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
</span><span id="TypeParser.parse_int-817"><a href="#TypeParser.parse_int-817"><span class="linenos">817</span></a>				<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span id="TypeParser.parse_int-818"><a href="#TypeParser.parse_int-818"><span class="linenos">818</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser.parse_int-819"><a href="#TypeParser.parse_int-819"><span class="linenos">819</span></a>
</span><span id="TypeParser.parse_int-820"><a href="#TypeParser.parse_int-820"><span class="linenos">820</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.parse_int-821"><a href="#TypeParser.parse_int-821"><span class="linenos">821</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span id="TypeParser.parse_int-822"><a href="#TypeParser.parse_int-822"><span class="linenos">822</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.parse_int-823"><a href="#TypeParser.parse_int-823"><span class="linenos">823</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not an integer: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a string and return it as an int if possible</p>

<p>If the string represents a bool, it will be converted to <code>1</code> for True and <code>0</code> for False.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be parsed</p>

<h2 id="keyword-arguments">Keyword arguments</h2>

<p><code>allow_negative</code>
: whether to accept negative values. Since negative values are always indicated with a negative sign, <code>allow_sign</code> must also be True (which is the default setting) for this to have any effect.</p>

<p><code>allow_sign</code>
: whether to accept values prepended with a sign character. If False, it implies that <code>allow_negative</code> is False also.</p>

<p><code>allow_scientific</code>
: whether to accept scientific notation. If True, strings of the form <code>"<var>M</var>e<var>X</var>"</code> will be interpreted as the expression <code><var>M</var> * (10 ** <var>X</var>)</code>, where <var>M</var> is the mantissa/significand and <var>X</var> is the exponent. Note that <var>M</var> must be an integer and <var>X</var> must be a non-negative integer, even in cases where the expression would evaluate mathematically to an integer.</p>

<h2 id="returns">Returns</h2>

<p>parsed int value</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code> if <code>value</code> cannot be parsed</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">)</span>    <span class="c1"># 0</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="s2">&quot;-1&quot;</span><span class="p">)</span>   <span class="c1"># -1</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="s2">&quot;2e3&quot;</span><span class="p">)</span>  <span class="c1"># 2000</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse_float" class="classattr">
                                        <input id="TypeParser.parse_float-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_float</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">float</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_float-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_float"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_float-871"><a href="#TypeParser.parse_float-871"><span class="linenos">871</span></a>	<span class="k">def</span> <span class="nf">parse_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
</span><span id="TypeParser.parse_float-872"><a href="#TypeParser.parse_float-872"><span class="linenos">872</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_float-873"><a href="#TypeParser.parse_float-873"><span class="linenos">873</span></a><span class="sd">			Parse a string and return it as a (non-exact) float if possible</span>
</span><span id="TypeParser.parse_float-874"><a href="#TypeParser.parse_float-874"><span class="linenos">874</span></a>
</span><span id="TypeParser.parse_float-875"><a href="#TypeParser.parse_float-875"><span class="linenos">875</span></a><span class="sd">			If the string represents a bool, it will be converted to `1.` for True and `0.` for False. If the string represents an int, it will be converted to a float also.</span>
</span><span id="TypeParser.parse_float-876"><a href="#TypeParser.parse_float-876"><span class="linenos">876</span></a>
</span><span id="TypeParser.parse_float-877"><a href="#TypeParser.parse_float-877"><span class="linenos">877</span></a><span class="sd">			Behaves analogously to `parse_decimal()`, except that that returns an exact Decimal instead.</span>
</span><span id="TypeParser.parse_float-878"><a href="#TypeParser.parse_float-878"><span class="linenos">878</span></a>
</span><span id="TypeParser.parse_float-879"><a href="#TypeParser.parse_float-879"><span class="linenos">879</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_float-880"><a href="#TypeParser.parse_float-880"><span class="linenos">880</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_float-881"><a href="#TypeParser.parse_float-881"><span class="linenos">881</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.parse_float-882"><a href="#TypeParser.parse_float-882"><span class="linenos">882</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser.parse_float-883"><a href="#TypeParser.parse_float-883"><span class="linenos">883</span></a>
</span><span id="TypeParser.parse_float-884"><a href="#TypeParser.parse_float-884"><span class="linenos">884</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser.parse_float-885"><a href="#TypeParser.parse_float-885"><span class="linenos">885</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser.parse_float-886"><a href="#TypeParser.parse_float-886"><span class="linenos">886</span></a>
</span><span id="TypeParser.parse_float-887"><a href="#TypeParser.parse_float-887"><span class="linenos">887</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser.parse_float-888"><a href="#TypeParser.parse_float-888"><span class="linenos">888</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
</span><span id="TypeParser.parse_float-889"><a href="#TypeParser.parse_float-889"><span class="linenos">889</span></a>
</span><span id="TypeParser.parse_float-890"><a href="#TypeParser.parse_float-890"><span class="linenos">890</span></a><span class="sd">			`allow_inf`</span>
</span><span id="TypeParser.parse_float-891"><a href="#TypeParser.parse_float-891"><span class="linenos">891</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.inf_values&lt;/code&gt; (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.parse_float-892"><a href="#TypeParser.parse_float-892"><span class="linenos">892</span></a>
</span><span id="TypeParser.parse_float-893"><a href="#TypeParser.parse_float-893"><span class="linenos">893</span></a><span class="sd">			`allow_nan`</span>
</span><span id="TypeParser.parse_float-894"><a href="#TypeParser.parse_float-894"><span class="linenos">894</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.nan_values&lt;/code&gt; (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.parse_float-895"><a href="#TypeParser.parse_float-895"><span class="linenos">895</span></a>
</span><span id="TypeParser.parse_float-896"><a href="#TypeParser.parse_float-896"><span class="linenos">896</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_float-897"><a href="#TypeParser.parse_float-897"><span class="linenos">897</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_float-898"><a href="#TypeParser.parse_float-898"><span class="linenos">898</span></a><span class="sd">			parsed float value</span>
</span><span id="TypeParser.parse_float-899"><a href="#TypeParser.parse_float-899"><span class="linenos">899</span></a>
</span><span id="TypeParser.parse_float-900"><a href="#TypeParser.parse_float-900"><span class="linenos">900</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.parse_float-901"><a href="#TypeParser.parse_float-901"><span class="linenos">901</span></a><span class="sd">			------</span>
</span><span id="TypeParser.parse_float-902"><a href="#TypeParser.parse_float-902"><span class="linenos">902</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser.parse_float-903"><a href="#TypeParser.parse_float-903"><span class="linenos">903</span></a>
</span><span id="TypeParser.parse_float-904"><a href="#TypeParser.parse_float-904"><span class="linenos">904</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_float-905"><a href="#TypeParser.parse_float-905"><span class="linenos">905</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_float-906"><a href="#TypeParser.parse_float-906"><span class="linenos">906</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_float-907"><a href="#TypeParser.parse_float-907"><span class="linenos">907</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
</span><span id="TypeParser.parse_float-908"><a href="#TypeParser.parse_float-908"><span class="linenos">908</span></a><span class="sd">			parser.parse_float(&quot;1.&quot;)       # 1.</span>
</span><span id="TypeParser.parse_float-909"><a href="#TypeParser.parse_float-909"><span class="linenos">909</span></a><span class="sd">			parser.parse_float(&quot;1.23e2&quot;)   # 123.</span>
</span><span id="TypeParser.parse_float-910"><a href="#TypeParser.parse_float-910"><span class="linenos">910</span></a><span class="sd">			parser.parse_float(&quot;1.23e-2&quot;)  # 0.0123</span>
</span><span id="TypeParser.parse_float-911"><a href="#TypeParser.parse_float-911"><span class="linenos">911</span></a><span class="sd">			parser.parse_float(&quot;inf&quot;)      # math.inf</span>
</span><span id="TypeParser.parse_float-912"><a href="#TypeParser.parse_float-912"><span class="linenos">912</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_float-913"><a href="#TypeParser.parse_float-913"><span class="linenos">913</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_float-914"><a href="#TypeParser.parse_float-914"><span class="linenos">914</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
</span><span id="TypeParser.parse_float-915"><a href="#TypeParser.parse_float-915"><span class="linenos">915</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
</span><span id="TypeParser.parse_float-916"><a href="#TypeParser.parse_float-916"><span class="linenos">916</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
</span><span id="TypeParser.parse_float-917"><a href="#TypeParser.parse_float-917"><span class="linenos">917</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
</span><span id="TypeParser.parse_float-918"><a href="#TypeParser.parse_float-918"><span class="linenos">918</span></a>		<span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a string and return it as a (non-exact) float if possible</p>

<p>If the string represents a bool, it will be converted to <code>1.</code> for True and <code>0.</code> for False. If the string represents an int, it will be converted to a float also.</p>

<p>Behaves analogously to <code><a href="#TypeParser.parse_decimal">parse_decimal()</a></code>, except that that returns an exact Decimal instead.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be parsed</p>

<h2 id="keyword-arguments">Keyword arguments</h2>

<p><code>allow_scientific</code>
: whether to accept scientific notation. If True, strings of the form <code>"<var>M</var>e<var>X</var>"</code> will be interpreted as the expression <code><var>M</var> * (10 ** <var>X</var>)</code>, where <var>M</var> is the mantissa/significand and <var>X</var> is the exponent. Note that <var>X</var> must be an integer, but can be negative.</p>

<p><code>allow_inf</code>
: whether to accept positive and negative infinity values. If True, strings that match the values in <code><var>parser</var>.inf_values</code> (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on <code><var>parser</var>.float_case_sensitive</code>, which is False by default.</p>

<p><code>allow_nan</code>
: whether to accept NaN (not a number) representations. If True, strings that match the values in <code><var>parser</var>.nan_values</code> (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on <code><var>parser</var>.float_case_sensitive</code>, which is False by default.</p>

<h2 id="returns">Returns</h2>

<p>parsed float value</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code> if <code>value</code> cannot be parsed</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">(</span><span class="n">inf_values</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;inf&quot;</span><span class="p">],</span> <span class="n">nan_values</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nan&quot;</span><span class="p">])</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="s2">&quot;1.&quot;</span><span class="p">)</span>       <span class="c1"># 1.</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="s2">&quot;1.23e2&quot;</span><span class="p">)</span>   <span class="c1"># 123.</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="s2">&quot;1.23e-2&quot;</span><span class="p">)</span>  <span class="c1"># 0.0123</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>      <span class="c1"># math.inf</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse_decimal" class="classattr">
                                        <input id="TypeParser.parse_decimal-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_decimal</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_decimal-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_decimal"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_decimal-921"><a href="#TypeParser.parse_decimal-921"><span class="linenos">921</span></a>	<span class="k">def</span> <span class="nf">parse_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
</span><span id="TypeParser.parse_decimal-922"><a href="#TypeParser.parse_decimal-922"><span class="linenos">922</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_decimal-923"><a href="#TypeParser.parse_decimal-923"><span class="linenos">923</span></a><span class="sd">			Parse a string and return it as an exact Decimal if possible</span>
</span><span id="TypeParser.parse_decimal-924"><a href="#TypeParser.parse_decimal-924"><span class="linenos">924</span></a>
</span><span id="TypeParser.parse_decimal-925"><a href="#TypeParser.parse_decimal-925"><span class="linenos">925</span></a><span class="sd">			If the string represents a bool, it will be converted to `Decimal(1)` for True and `Decimal(0)` for False. If the string represents an int, it will be converted to a Decimal also.</span>
</span><span id="TypeParser.parse_decimal-926"><a href="#TypeParser.parse_decimal-926"><span class="linenos">926</span></a>
</span><span id="TypeParser.parse_decimal-927"><a href="#TypeParser.parse_decimal-927"><span class="linenos">927</span></a><span class="sd">			Behaves analogously to `parse_float()`, except that that returns a non-exact float instead.</span>
</span><span id="TypeParser.parse_decimal-928"><a href="#TypeParser.parse_decimal-928"><span class="linenos">928</span></a>
</span><span id="TypeParser.parse_decimal-929"><a href="#TypeParser.parse_decimal-929"><span class="linenos">929</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_decimal-930"><a href="#TypeParser.parse_decimal-930"><span class="linenos">930</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_decimal-931"><a href="#TypeParser.parse_decimal-931"><span class="linenos">931</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.parse_decimal-932"><a href="#TypeParser.parse_decimal-932"><span class="linenos">932</span></a><span class="sd">			: string to be parsed</span>
</span><span id="TypeParser.parse_decimal-933"><a href="#TypeParser.parse_decimal-933"><span class="linenos">933</span></a>
</span><span id="TypeParser.parse_decimal-934"><a href="#TypeParser.parse_decimal-934"><span class="linenos">934</span></a><span class="sd">			Keyword arguments</span>
</span><span id="TypeParser.parse_decimal-935"><a href="#TypeParser.parse_decimal-935"><span class="linenos">935</span></a><span class="sd">			-----------------</span>
</span><span id="TypeParser.parse_decimal-936"><a href="#TypeParser.parse_decimal-936"><span class="linenos">936</span></a>
</span><span id="TypeParser.parse_decimal-937"><a href="#TypeParser.parse_decimal-937"><span class="linenos">937</span></a><span class="sd">			`allow_scientific`</span>
</span><span id="TypeParser.parse_decimal-938"><a href="#TypeParser.parse_decimal-938"><span class="linenos">938</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form &lt;code&gt;&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;&lt;/code&gt; will be interpreted as the expression &lt;code&gt;&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
</span><span id="TypeParser.parse_decimal-939"><a href="#TypeParser.parse_decimal-939"><span class="linenos">939</span></a>
</span><span id="TypeParser.parse_decimal-940"><a href="#TypeParser.parse_decimal-940"><span class="linenos">940</span></a><span class="sd">			`allow_inf`</span>
</span><span id="TypeParser.parse_decimal-941"><a href="#TypeParser.parse_decimal-941"><span class="linenos">941</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.inf_values&lt;/code&gt; (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.parse_decimal-942"><a href="#TypeParser.parse_decimal-942"><span class="linenos">942</span></a>
</span><span id="TypeParser.parse_decimal-943"><a href="#TypeParser.parse_decimal-943"><span class="linenos">943</span></a><span class="sd">			`allow_nan`</span>
</span><span id="TypeParser.parse_decimal-944"><a href="#TypeParser.parse_decimal-944"><span class="linenos">944</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.nan_values&lt;/code&gt; (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.float_case_sensitive&lt;/code&gt;, which is False by default.</span>
</span><span id="TypeParser.parse_decimal-945"><a href="#TypeParser.parse_decimal-945"><span class="linenos">945</span></a>
</span><span id="TypeParser.parse_decimal-946"><a href="#TypeParser.parse_decimal-946"><span class="linenos">946</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_decimal-947"><a href="#TypeParser.parse_decimal-947"><span class="linenos">947</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_decimal-948"><a href="#TypeParser.parse_decimal-948"><span class="linenos">948</span></a><span class="sd">			parsed Decimal value</span>
</span><span id="TypeParser.parse_decimal-949"><a href="#TypeParser.parse_decimal-949"><span class="linenos">949</span></a>
</span><span id="TypeParser.parse_decimal-950"><a href="#TypeParser.parse_decimal-950"><span class="linenos">950</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.parse_decimal-951"><a href="#TypeParser.parse_decimal-951"><span class="linenos">951</span></a><span class="sd">			------</span>
</span><span id="TypeParser.parse_decimal-952"><a href="#TypeParser.parse_decimal-952"><span class="linenos">952</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
</span><span id="TypeParser.parse_decimal-953"><a href="#TypeParser.parse_decimal-953"><span class="linenos">953</span></a>
</span><span id="TypeParser.parse_decimal-954"><a href="#TypeParser.parse_decimal-954"><span class="linenos">954</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_decimal-955"><a href="#TypeParser.parse_decimal-955"><span class="linenos">955</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_decimal-956"><a href="#TypeParser.parse_decimal-956"><span class="linenos">956</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_decimal-957"><a href="#TypeParser.parse_decimal-957"><span class="linenos">957</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
</span><span id="TypeParser.parse_decimal-958"><a href="#TypeParser.parse_decimal-958"><span class="linenos">958</span></a><span class="sd">			parser.parse_decimal(&quot;1.&quot;)       # Decimal(1)</span>
</span><span id="TypeParser.parse_decimal-959"><a href="#TypeParser.parse_decimal-959"><span class="linenos">959</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e2&quot;)   # Decimal(123)</span>
</span><span id="TypeParser.parse_decimal-960"><a href="#TypeParser.parse_decimal-960"><span class="linenos">960</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e-2&quot;)  # Decimal(123) / Decimal(10000)</span>
</span><span id="TypeParser.parse_decimal-961"><a href="#TypeParser.parse_decimal-961"><span class="linenos">961</span></a><span class="sd">			parser.parse_decimal(&quot;inf&quot;)      # Decimal(math.inf)</span>
</span><span id="TypeParser.parse_decimal-962"><a href="#TypeParser.parse_decimal-962"><span class="linenos">962</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_decimal-963"><a href="#TypeParser.parse_decimal-963"><span class="linenos">963</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_decimal-964"><a href="#TypeParser.parse_decimal-964"><span class="linenos">964</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
</span><span id="TypeParser.parse_decimal-965"><a href="#TypeParser.parse_decimal-965"><span class="linenos">965</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
</span><span id="TypeParser.parse_decimal-966"><a href="#TypeParser.parse_decimal-966"><span class="linenos">966</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
</span><span id="TypeParser.parse_decimal-967"><a href="#TypeParser.parse_decimal-967"><span class="linenos">967</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
</span><span id="TypeParser.parse_decimal-968"><a href="#TypeParser.parse_decimal-968"><span class="linenos">968</span></a>		<span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a string and return it as an exact Decimal if possible</p>

<p>If the string represents a bool, it will be converted to <code>Decimal(1)</code> for True and <code>Decimal(0)</code> for False. If the string represents an int, it will be converted to a Decimal also.</p>

<p>Behaves analogously to <code><a href="#TypeParser.parse_float">parse_float()</a></code>, except that that returns a non-exact float instead.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: string to be parsed</p>

<h2 id="keyword-arguments">Keyword arguments</h2>

<p><code>allow_scientific</code>
: whether to accept scientific notation. If True, strings of the form <code>"<var>M</var>e<var>X</var>"</code> will be interpreted as the expression <code><var>M</var> * (10 ** <var>X</var>)</code>, where <var>M</var> is the mantissa/significand and <var>X</var> is the exponent. Note that <var>X</var> must be an integer, but can be negative.</p>

<p><code>allow_inf</code>
: whether to accept positive and negative infinity values. If True, strings that match the values in <code><var>parser</var>.inf_values</code> (empty set by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on <code><var>parser</var>.float_case_sensitive</code>, which is False by default.</p>

<p><code>allow_nan</code>
: whether to accept NaN (not a number) representations. If True, strings that match the values in <code><var>parser</var>.nan_values</code> (empty set by default) are interpeted as NaN. The case sensitivity of this matching also depends on <code><var>parser</var>.float_case_sensitive</code>, which is False by default.</p>

<h2 id="returns">Returns</h2>

<p>parsed Decimal value</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code> if <code>value</code> cannot be parsed</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">(</span><span class="n">inf_values</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;inf&quot;</span><span class="p">],</span> <span class="n">nan_values</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nan&quot;</span><span class="p">])</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="s2">&quot;1.&quot;</span><span class="p">)</span>       <span class="c1"># Decimal(1)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="s2">&quot;1.23e2&quot;</span><span class="p">)</span>   <span class="c1"># Decimal(123)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="s2">&quot;1.23e-2&quot;</span><span class="p">)</span>  <span class="c1"># Decimal(123) / Decimal(10000)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>      <span class="c1"># Decimal(math.inf)</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.infer" class="classattr">
                                        <input id="TypeParser.infer-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">infer</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n"><a href="#Nullable">Nullable</a></span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.infer-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.infer"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer-971"><a href="#TypeParser.infer-971"><span class="linenos"> 971</span></a>	<span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
</span><span id="TypeParser.infer-972"><a href="#TypeParser.infer-972"><span class="linenos"> 972</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.infer-973"><a href="#TypeParser.infer-973"><span class="linenos"> 973</span></a><span class="sd">			Infer the underlying type of a string</span>
</span><span id="TypeParser.infer-974"><a href="#TypeParser.infer-974"><span class="linenos"> 974</span></a>
</span><span id="TypeParser.infer-975"><a href="#TypeParser.infer-975"><span class="linenos"> 975</span></a><span class="sd">			Also check for inline lists if &lt;code&gt;&lt;var&gt;parser&lt;/var&gt;.list_delimiter&lt;/code&gt; is not None.</span>
</span><span id="TypeParser.infer-976"><a href="#TypeParser.infer-976"><span class="linenos"> 976</span></a>
</span><span id="TypeParser.infer-977"><a href="#TypeParser.infer-977"><span class="linenos"> 977</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.infer-978"><a href="#TypeParser.infer-978"><span class="linenos"> 978</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.infer-979"><a href="#TypeParser.infer-979"><span class="linenos"> 979</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.infer-980"><a href="#TypeParser.infer-980"><span class="linenos"> 980</span></a><span class="sd">			: the string for which the type should be inferred</span>
</span><span id="TypeParser.infer-981"><a href="#TypeParser.infer-981"><span class="linenos"> 981</span></a>
</span><span id="TypeParser.infer-982"><a href="#TypeParser.infer-982"><span class="linenos"> 982</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.infer-983"><a href="#TypeParser.infer-983"><span class="linenos"> 983</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.infer-984"><a href="#TypeParser.infer-984"><span class="linenos"> 984</span></a><span class="sd">			inferred type</span>
</span><span id="TypeParser.infer-985"><a href="#TypeParser.infer-985"><span class="linenos"> 985</span></a>
</span><span id="TypeParser.infer-986"><a href="#TypeParser.infer-986"><span class="linenos"> 986</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.infer-987"><a href="#TypeParser.infer-987"><span class="linenos"> 987</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.infer-988"><a href="#TypeParser.infer-988"><span class="linenos"> 988</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.infer-989"><a href="#TypeParser.infer-989"><span class="linenos"> 989</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.infer-990"><a href="#TypeParser.infer-990"><span class="linenos"> 990</span></a><span class="sd">			parser.infer(&quot;true&quot;)  # bool</span>
</span><span id="TypeParser.infer-991"><a href="#TypeParser.infer-991"><span class="linenos"> 991</span></a><span class="sd">			parser.infer(&quot;2.0&quot;)   # float</span>
</span><span id="TypeParser.infer-992"><a href="#TypeParser.infer-992"><span class="linenos"> 992</span></a><span class="sd">			parser.infer(&quot;abc&quot;)   # str</span>
</span><span id="TypeParser.infer-993"><a href="#TypeParser.infer-993"><span class="linenos"> 993</span></a><span class="sd">			```</span>
</span><span id="TypeParser.infer-994"><a href="#TypeParser.infer-994"><span class="linenos"> 994</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.infer-995"><a href="#TypeParser.infer-995"><span class="linenos"> 995</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.infer-996"><a href="#TypeParser.infer-996"><span class="linenos"> 996</span></a>			<span class="k">return</span> <span class="n">NoneType</span>
</span><span id="TypeParser.infer-997"><a href="#TypeParser.infer-997"><span class="linenos"> 997</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.infer-998"><a href="#TypeParser.infer-998"><span class="linenos"> 998</span></a>			<span class="k">return</span> <span class="nb">bool</span>
</span><span id="TypeParser.infer-999"><a href="#TypeParser.infer-999"><span class="linenos"> 999</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.infer-1000"><a href="#TypeParser.infer-1000"><span class="linenos">1000</span></a>			<span class="k">return</span> <span class="nb">int</span>
</span><span id="TypeParser.infer-1001"><a href="#TypeParser.infer-1001"><span class="linenos">1001</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.infer-1002"><a href="#TypeParser.infer-1002"><span class="linenos">1002</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_decimal</span><span class="p">:</span>
</span><span id="TypeParser.infer-1003"><a href="#TypeParser.infer-1003"><span class="linenos">1003</span></a>				<span class="k">return</span> <span class="n">Decimal</span>
</span><span id="TypeParser.infer-1004"><a href="#TypeParser.infer-1004"><span class="linenos">1004</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.infer-1005"><a href="#TypeParser.infer-1005"><span class="linenos">1005</span></a>				<span class="k">return</span> <span class="nb">float</span>
</span><span id="TypeParser.infer-1006"><a href="#TypeParser.infer-1006"><span class="linenos">1006</span></a>
</span><span id="TypeParser.infer-1007"><a href="#TypeParser.infer-1007"><span class="linenos">1007</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.infer-1008"><a href="#TypeParser.infer-1008"><span class="linenos">1008</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span id="TypeParser.infer-1009"><a href="#TypeParser.infer-1009"><span class="linenos">1009</span></a>
</span><span id="TypeParser.infer-1010"><a href="#TypeParser.infer-1010"><span class="linenos">1010</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
</span><span id="TypeParser.infer-1011"><a href="#TypeParser.infer-1011"><span class="linenos">1011</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">)</span>
</span><span id="TypeParser.infer-1012"><a href="#TypeParser.infer-1012"><span class="linenos">1012</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.infer-1013"><a href="#TypeParser.infer-1013"><span class="linenos">1013</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
</span><span id="TypeParser.infer-1014"><a href="#TypeParser.infer-1014"><span class="linenos">1014</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">subvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">)</span>
</span><span id="TypeParser.infer-1015"><a href="#TypeParser.infer-1015"><span class="linenos">1015</span></a>			<span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">reduced_type</span><span class="p">]</span>
</span><span id="TypeParser.infer-1016"><a href="#TypeParser.infer-1016"><span class="linenos">1016</span></a>			<span class="k">return</span> <span class="n">r</span>
</span><span id="TypeParser.infer-1017"><a href="#TypeParser.infer-1017"><span class="linenos">1017</span></a>
</span><span id="TypeParser.infer-1018"><a href="#TypeParser.infer-1018"><span class="linenos">1018</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
</span></pre></div>


    <div class="docstring">
<p>Infer the underlying type of a string</p>

<p>Also check for inline lists if <code><var>parser</var>.list_delimiter</code> is not None.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: the string for which the type should be inferred</p>

<h2 id="returns">Returns</h2>

<p>inferred type</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>  <span class="c1"># bool</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">)</span>   <span class="c1"># float</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>   <span class="c1"># str</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.infer_series" class="classattr">
                                        <input id="TypeParser.infer_series-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">infer_series</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n"><a href="#Nullable">Nullable</a></span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.infer_series-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.infer_series"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer_series-1021"><a href="#TypeParser.infer_series-1021"><span class="linenos">1021</span></a>	<span class="k">def</span> <span class="nf">infer_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
</span><span id="TypeParser.infer_series-1022"><a href="#TypeParser.infer_series-1022"><span class="linenos">1022</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.infer_series-1023"><a href="#TypeParser.infer_series-1023"><span class="linenos">1023</span></a><span class="sd">			Infer the underlying common type of a series of strings</span>
</span><span id="TypeParser.infer_series-1024"><a href="#TypeParser.infer_series-1024"><span class="linenos">1024</span></a>
</span><span id="TypeParser.infer_series-1025"><a href="#TypeParser.infer_series-1025"><span class="linenos">1025</span></a><span class="sd">			If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser.infer_series-1026"><a href="#TypeParser.infer_series-1026"><span class="linenos">1026</span></a>
</span><span id="TypeParser.infer_series-1027"><a href="#TypeParser.infer_series-1027"><span class="linenos">1027</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.infer_series-1028"><a href="#TypeParser.infer_series-1028"><span class="linenos">1028</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.infer_series-1029"><a href="#TypeParser.infer_series-1029"><span class="linenos">1029</span></a><span class="sd">			`values`</span>
</span><span id="TypeParser.infer_series-1030"><a href="#TypeParser.infer_series-1030"><span class="linenos">1030</span></a><span class="sd">			: series of strings for which the type should be inferred</span>
</span><span id="TypeParser.infer_series-1031"><a href="#TypeParser.infer_series-1031"><span class="linenos">1031</span></a>
</span><span id="TypeParser.infer_series-1032"><a href="#TypeParser.infer_series-1032"><span class="linenos">1032</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.infer_series-1033"><a href="#TypeParser.infer_series-1033"><span class="linenos">1033</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.infer_series-1034"><a href="#TypeParser.infer_series-1034"><span class="linenos">1034</span></a><span class="sd">			inferred type</span>
</span><span id="TypeParser.infer_series-1035"><a href="#TypeParser.infer_series-1035"><span class="linenos">1035</span></a>
</span><span id="TypeParser.infer_series-1036"><a href="#TypeParser.infer_series-1036"><span class="linenos">1036</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.infer_series-1037"><a href="#TypeParser.infer_series-1037"><span class="linenos">1037</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.infer_series-1038"><a href="#TypeParser.infer_series-1038"><span class="linenos">1038</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.infer_series-1039"><a href="#TypeParser.infer_series-1039"><span class="linenos">1039</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.infer_series-1040"><a href="#TypeParser.infer_series-1040"><span class="linenos">1040</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2&quot;, &quot;3.4&quot;])       # float</span>
</span><span id="TypeParser.infer_series-1041"><a href="#TypeParser.infer_series-1041"><span class="linenos">1041</span></a><span class="sd">			parser.infer_series([&quot;true&quot;, &quot;false&quot;, &quot;2&quot;])  # int</span>
</span><span id="TypeParser.infer_series-1042"><a href="#TypeParser.infer_series-1042"><span class="linenos">1042</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])     # str</span>
</span><span id="TypeParser.infer_series-1043"><a href="#TypeParser.infer_series-1043"><span class="linenos">1043</span></a><span class="sd">			```</span>
</span><span id="TypeParser.infer_series-1044"><a href="#TypeParser.infer_series-1044"><span class="linenos">1044</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.infer_series-1045"><a href="#TypeParser.infer_series-1045"><span class="linenos">1045</span></a>		<span class="k">return</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Infer the underlying common type of a series of strings</p>

<p>If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>

<h2 id="arguments">Arguments</h2>

<p><code>values</code>
: series of strings for which the type should be inferred</p>

<h2 id="returns">Returns</h2>

<p>inferred type</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer_series</span><span class="p">([</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3.4&quot;</span><span class="p">])</span>       <span class="c1"># float</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer_series</span><span class="p">([</span><span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">])</span>  <span class="c1"># int</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer_series</span><span class="p">([</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">])</span>     <span class="c1"># str</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.infer_table" class="classattr">
                                        <input id="TypeParser.infer_table-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">infer_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n"><a href="#Nullable">Nullable</a></span><span class="p">,</span> <span class="nb">list</span><span class="p">]]]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.infer_table-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.infer_table"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer_table-1048"><a href="#TypeParser.infer_table-1048"><span class="linenos">1048</span></a>	<span class="k">def</span> <span class="nf">infer_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">]:</span>
</span><span id="TypeParser.infer_table-1049"><a href="#TypeParser.infer_table-1049"><span class="linenos">1049</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.infer_table-1050"><a href="#TypeParser.infer_table-1050"><span class="linenos">1050</span></a><span class="sd">			Infer the underlying common type for each column of a table of strings</span>
</span><span id="TypeParser.infer_table-1051"><a href="#TypeParser.infer_table-1051"><span class="linenos">1051</span></a>
</span><span id="TypeParser.infer_table-1052"><a href="#TypeParser.infer_table-1052"><span class="linenos">1052</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser.infer_table-1053"><a href="#TypeParser.infer_table-1053"><span class="linenos">1053</span></a>
</span><span id="TypeParser.infer_table-1054"><a href="#TypeParser.infer_table-1054"><span class="linenos">1054</span></a><span class="sd">			Note that the individual inferred types of every value in the table must be able to fit into memory.</span>
</span><span id="TypeParser.infer_table-1055"><a href="#TypeParser.infer_table-1055"><span class="linenos">1055</span></a>
</span><span id="TypeParser.infer_table-1056"><a href="#TypeParser.infer_table-1056"><span class="linenos">1056</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.infer_table-1057"><a href="#TypeParser.infer_table-1057"><span class="linenos">1057</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.infer_table-1058"><a href="#TypeParser.infer_table-1058"><span class="linenos">1058</span></a><span class="sd">			`rows`</span>
</span><span id="TypeParser.infer_table-1059"><a href="#TypeParser.infer_table-1059"><span class="linenos">1059</span></a><span class="sd">			: table of strings for which the types should be inferred, in row-major order</span>
</span><span id="TypeParser.infer_table-1060"><a href="#TypeParser.infer_table-1060"><span class="linenos">1060</span></a>
</span><span id="TypeParser.infer_table-1061"><a href="#TypeParser.infer_table-1061"><span class="linenos">1061</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.infer_table-1062"><a href="#TypeParser.infer_table-1062"><span class="linenos">1062</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.infer_table-1063"><a href="#TypeParser.infer_table-1063"><span class="linenos">1063</span></a><span class="sd">			inferred types</span>
</span><span id="TypeParser.infer_table-1064"><a href="#TypeParser.infer_table-1064"><span class="linenos">1064</span></a>
</span><span id="TypeParser.infer_table-1065"><a href="#TypeParser.infer_table-1065"><span class="linenos">1065</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.infer_table-1066"><a href="#TypeParser.infer_table-1066"><span class="linenos">1066</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.infer_table-1067"><a href="#TypeParser.infer_table-1067"><span class="linenos">1067</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.infer_table-1068"><a href="#TypeParser.infer_table-1068"><span class="linenos">1068</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.infer_table-1069"><a href="#TypeParser.infer_table-1069"><span class="linenos">1069</span></a><span class="sd">			parser.infer_table([</span>
</span><span id="TypeParser.infer_table-1070"><a href="#TypeParser.infer_table-1070"><span class="linenos">1070</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
</span><span id="TypeParser.infer_table-1071"><a href="#TypeParser.infer_table-1071"><span class="linenos">1071</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
</span><span id="TypeParser.infer_table-1072"><a href="#TypeParser.infer_table-1072"><span class="linenos">1072</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
</span><span id="TypeParser.infer_table-1073"><a href="#TypeParser.infer_table-1073"><span class="linenos">1073</span></a><span class="sd">			])</span>
</span><span id="TypeParser.infer_table-1074"><a href="#TypeParser.infer_table-1074"><span class="linenos">1074</span></a><span class="sd">			# [float, int, str]</span>
</span><span id="TypeParser.infer_table-1075"><a href="#TypeParser.infer_table-1075"><span class="linenos">1075</span></a><span class="sd">			```</span>
</span><span id="TypeParser.infer_table-1076"><a href="#TypeParser.infer_table-1076"><span class="linenos">1076</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.infer_table-1077"><a href="#TypeParser.infer_table-1077"><span class="linenos">1077</span></a>		<span class="n">rows_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span><span id="TypeParser.infer_table-1078"><a href="#TypeParser.infer_table-1078"><span class="linenos">1078</span></a>		<span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rows_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="TypeParser.infer_table-1079"><a href="#TypeParser.infer_table-1079"><span class="linenos">1079</span></a>		<span class="k">if</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="TypeParser.infer_table-1080"><a href="#TypeParser.infer_table-1080"><span class="linenos">1080</span></a>			<span class="k">return</span> <span class="p">[]</span>
</span><span id="TypeParser.infer_table-1081"><a href="#TypeParser.infer_table-1081"><span class="linenos">1081</span></a>
</span><span id="TypeParser.infer_table-1082"><a href="#TypeParser.infer_table-1082"><span class="linenos">1082</span></a>		<span class="n">num_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">)</span>
</span><span id="TypeParser.infer_table-1083"><a href="#TypeParser.infer_table-1083"><span class="linenos">1083</span></a>		<span class="k">if</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span id="TypeParser.infer_table-1084"><a href="#TypeParser.infer_table-1084"><span class="linenos">1084</span></a>			<span class="k">return</span> <span class="p">[]</span>
</span><span id="TypeParser.infer_table-1085"><a href="#TypeParser.infer_table-1085"><span class="linenos">1085</span></a>
</span><span id="TypeParser.infer_table-1086"><a href="#TypeParser.infer_table-1086"><span class="linenos">1086</span></a>		<span class="n">table</span> <span class="o">=</span> <span class="n">_TypeTable</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">])</span>
</span><span id="TypeParser.infer_table-1087"><a href="#TypeParser.infer_table-1087"><span class="linenos">1087</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows_iter</span><span class="p">:</span>
</span><span id="TypeParser.infer_table-1088"><a href="#TypeParser.infer_table-1088"><span class="linenos">1088</span></a>			<span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
</span><span id="TypeParser.infer_table-1089"><a href="#TypeParser.infer_table-1089"><span class="linenos">1089</span></a>
</span><span id="TypeParser.infer_table-1090"><a href="#TypeParser.infer_table-1090"><span class="linenos">1090</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">reduce_types</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
</span></pre></div>


    <div class="docstring">
<p>Infer the underlying common type for each column of a table of strings</p>

<p>For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>

<p>Note that the individual inferred types of every value in the table must be able to fit into memory.</p>

<h2 id="arguments">Arguments</h2>

<p><code>rows</code>
: table of strings for which the types should be inferred, in row-major order</p>

<h2 id="returns">Returns</h2>

<p>inferred types</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">infer_table</span><span class="p">([</span>
	<span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span>   <span class="s2">&quot;true&quot;</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">,</span>   <span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="s2">&quot;3.4&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span>     <span class="s2">&quot;abc&quot;</span><span class="p">],</span>
<span class="p">])</span>
<span class="c1"># [float, int, str]</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.convert" class="classattr">
                                        <input id="TypeParser.convert-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">convert</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="n">target_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n"><a href="#Nullable">Nullable</a></span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.convert-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.convert"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.convert-1093"><a href="#TypeParser.convert-1093"><span class="linenos">1093</span></a>	<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_type</span><span class="p">:</span> <span class="n">AnyValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
</span><span id="TypeParser.convert-1094"><a href="#TypeParser.convert-1094"><span class="linenos">1094</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.convert-1095"><a href="#TypeParser.convert-1095"><span class="linenos">1095</span></a><span class="sd">			Convert a string to the specified target type if possible</span>
</span><span id="TypeParser.convert-1096"><a href="#TypeParser.convert-1096"><span class="linenos">1096</span></a>
</span><span id="TypeParser.convert-1097"><a href="#TypeParser.convert-1097"><span class="linenos">1097</span></a><span class="sd">			Valid values for `target_type` include any return value from `infer()`, `infer_series()` and `infer_table()`. To infer and convert the string automatically, use `parse()`, `parse_series()` or `parse_table()` instead.</span>
</span><span id="TypeParser.convert-1098"><a href="#TypeParser.convert-1098"><span class="linenos">1098</span></a>
</span><span id="TypeParser.convert-1099"><a href="#TypeParser.convert-1099"><span class="linenos">1099</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.convert-1100"><a href="#TypeParser.convert-1100"><span class="linenos">1100</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.convert-1101"><a href="#TypeParser.convert-1101"><span class="linenos">1101</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.convert-1102"><a href="#TypeParser.convert-1102"><span class="linenos">1102</span></a><span class="sd">			: the string to be converted</span>
</span><span id="TypeParser.convert-1103"><a href="#TypeParser.convert-1103"><span class="linenos">1103</span></a>
</span><span id="TypeParser.convert-1104"><a href="#TypeParser.convert-1104"><span class="linenos">1104</span></a><span class="sd">			`target_type`</span>
</span><span id="TypeParser.convert-1105"><a href="#TypeParser.convert-1105"><span class="linenos">1105</span></a><span class="sd">			: type to which the value should be converted</span>
</span><span id="TypeParser.convert-1106"><a href="#TypeParser.convert-1106"><span class="linenos">1106</span></a>
</span><span id="TypeParser.convert-1107"><a href="#TypeParser.convert-1107"><span class="linenos">1107</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.convert-1108"><a href="#TypeParser.convert-1108"><span class="linenos">1108</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.convert-1109"><a href="#TypeParser.convert-1109"><span class="linenos">1109</span></a><span class="sd">			converted value</span>
</span><span id="TypeParser.convert-1110"><a href="#TypeParser.convert-1110"><span class="linenos">1110</span></a>
</span><span id="TypeParser.convert-1111"><a href="#TypeParser.convert-1111"><span class="linenos">1111</span></a><span class="sd">			Raises</span>
</span><span id="TypeParser.convert-1112"><a href="#TypeParser.convert-1112"><span class="linenos">1112</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.convert-1113"><a href="#TypeParser.convert-1113"><span class="linenos">1113</span></a><span class="sd">			`ValueError`</span>
</span><span id="TypeParser.convert-1114"><a href="#TypeParser.convert-1114"><span class="linenos">1114</span></a><span class="sd">			: if `value` cannot be converted to `target_type`</span>
</span><span id="TypeParser.convert-1115"><a href="#TypeParser.convert-1115"><span class="linenos">1115</span></a>
</span><span id="TypeParser.convert-1116"><a href="#TypeParser.convert-1116"><span class="linenos">1116</span></a><span class="sd">			`TypeError`</span>
</span><span id="TypeParser.convert-1117"><a href="#TypeParser.convert-1117"><span class="linenos">1117</span></a><span class="sd">			: if `target_type` is not a valid type</span>
</span><span id="TypeParser.convert-1118"><a href="#TypeParser.convert-1118"><span class="linenos">1118</span></a>
</span><span id="TypeParser.convert-1119"><a href="#TypeParser.convert-1119"><span class="linenos">1119</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.convert-1120"><a href="#TypeParser.convert-1120"><span class="linenos">1120</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.convert-1121"><a href="#TypeParser.convert-1121"><span class="linenos">1121</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.convert-1122"><a href="#TypeParser.convert-1122"><span class="linenos">1122</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.convert-1123"><a href="#TypeParser.convert-1123"><span class="linenos">1123</span></a><span class="sd">			parser.convert(&quot;true&quot;, bool)  # True</span>
</span><span id="TypeParser.convert-1124"><a href="#TypeParser.convert-1124"><span class="linenos">1124</span></a><span class="sd">			parser.convert(&quot;2&quot;, int)      # 2</span>
</span><span id="TypeParser.convert-1125"><a href="#TypeParser.convert-1125"><span class="linenos">1125</span></a><span class="sd">			parser.convert(&quot;2&quot;, float)    # 2.</span>
</span><span id="TypeParser.convert-1126"><a href="#TypeParser.convert-1126"><span class="linenos">1126</span></a><span class="sd">			```</span>
</span><span id="TypeParser.convert-1127"><a href="#TypeParser.convert-1127"><span class="linenos">1127</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.convert-1128"><a href="#TypeParser.convert-1128"><span class="linenos">1128</span></a>		<span class="n">base</span><span class="p">,</span> <span class="n">type_args</span> <span class="o">=</span> <span class="n">_decompose_type</span><span class="p">(</span><span class="n">target_type</span><span class="p">)</span>
</span><span id="TypeParser.convert-1129"><a href="#TypeParser.convert-1129"><span class="linenos">1129</span></a>		<span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="n">NoneType</span><span class="p">:</span>
</span><span id="TypeParser.convert-1130"><a href="#TypeParser.convert-1130"><span class="linenos">1130</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_none</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser.convert-1131"><a href="#TypeParser.convert-1131"><span class="linenos">1131</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="TypeParser.convert-1132"><a href="#TypeParser.convert-1132"><span class="linenos">1132</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser.convert-1133"><a href="#TypeParser.convert-1133"><span class="linenos">1133</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="TypeParser.convert-1134"><a href="#TypeParser.convert-1134"><span class="linenos">1134</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser.convert-1135"><a href="#TypeParser.convert-1135"><span class="linenos">1135</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Decimal</span><span class="p">:</span>
</span><span id="TypeParser.convert-1136"><a href="#TypeParser.convert-1136"><span class="linenos">1136</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser.convert-1137"><a href="#TypeParser.convert-1137"><span class="linenos">1137</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
</span><span id="TypeParser.convert-1138"><a href="#TypeParser.convert-1138"><span class="linenos">1138</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span id="TypeParser.convert-1139"><a href="#TypeParser.convert-1139"><span class="linenos">1139</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser.convert-1140"><a href="#TypeParser.convert-1140"><span class="linenos">1140</span></a>			<span class="k">return</span> <span class="n">value</span>
</span><span id="TypeParser.convert-1141"><a href="#TypeParser.convert-1141"><span class="linenos">1141</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Nullable</span><span class="p">:</span>
</span><span id="TypeParser.convert-1142"><a href="#TypeParser.convert-1142"><span class="linenos">1142</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
</span><span id="TypeParser.convert-1143"><a href="#TypeParser.convert-1143"><span class="linenos">1143</span></a>				<span class="k">return</span> <span class="kc">None</span>
</span><span id="TypeParser.convert-1144"><a href="#TypeParser.convert-1144"><span class="linenos">1144</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.convert-1145"><a href="#TypeParser.convert-1145"><span class="linenos">1145</span></a>				<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser.convert-1146"><a href="#TypeParser.convert-1146"><span class="linenos">1146</span></a>					<span class="n">inner_type</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="TypeParser.convert-1147"><a href="#TypeParser.convert-1147"><span class="linenos">1147</span></a>					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inner_type</span><span class="p">)</span>
</span><span id="TypeParser.convert-1148"><a href="#TypeParser.convert-1148"><span class="linenos">1148</span></a>				<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.convert-1149"><a href="#TypeParser.convert-1149"><span class="linenos">1149</span></a>					<span class="k">return</span> <span class="n">value</span>
</span><span id="TypeParser.convert-1150"><a href="#TypeParser.convert-1150"><span class="linenos">1150</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
</span><span id="TypeParser.convert-1151"><a href="#TypeParser.convert-1151"><span class="linenos">1151</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list_delimiter</span><span class="p">)</span>
</span><span id="TypeParser.convert-1152"><a href="#TypeParser.convert-1152"><span class="linenos">1152</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">:</span>
</span><span id="TypeParser.convert-1153"><a href="#TypeParser.convert-1153"><span class="linenos">1153</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
</span><span id="TypeParser.convert-1154"><a href="#TypeParser.convert-1154"><span class="linenos">1154</span></a>			<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="TypeParser.convert-1155"><a href="#TypeParser.convert-1155"><span class="linenos">1155</span></a>				<span class="n">subtype</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="TypeParser.convert-1156"><a href="#TypeParser.convert-1156"><span class="linenos">1156</span></a>				<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">subvalue</span><span class="p">,</span> <span class="n">subtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
</span><span id="TypeParser.convert-1157"><a href="#TypeParser.convert-1157"><span class="linenos">1157</span></a>			<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.convert-1158"><a href="#TypeParser.convert-1158"><span class="linenos">1158</span></a>				<span class="k">return</span> <span class="n">subvalues</span>
</span><span id="TypeParser.convert-1159"><a href="#TypeParser.convert-1159"><span class="linenos">1159</span></a>		<span class="k">else</span><span class="p">:</span>
</span><span id="TypeParser.convert-1160"><a href="#TypeParser.convert-1160"><span class="linenos">1160</span></a>			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot convert to type: </span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span></pre></div>


    <div class="docstring">
<p>Convert a string to the specified target type if possible</p>

<p>Valid values for <code>target_type</code> include any return value from <code><a href="#TypeParser.infer">infer()</a></code>, <code><a href="#TypeParser.infer_series">infer_series()</a></code> and <code><a href="#TypeParser.infer_table">infer_table()</a></code>. To infer and convert the string automatically, use <code><a href="#TypeParser.parse">parse()</a></code>, <code><a href="#TypeParser.parse_series">parse_series()</a></code> or <code><a href="#TypeParser.parse_table">parse_table()</a></code> instead.</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: the string to be converted</p>

<p><code>target_type</code>
: type to which the value should be converted</p>

<h2 id="returns">Returns</h2>

<p>converted value</p>

<h2 id="raises">Raises</h2>

<p><code>ValueError</code>
: if <code>value</code> cannot be converted to <code>target_type</code></p>

<p><code>TypeError</code>
: if <code>target_type</code> is not a valid type</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>      <span class="c1"># 2</span>
<span class="n">parser</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>    <span class="c1"># 2.</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse" class="classattr">
                                        <input id="TypeParser.parse-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse-1163"><a href="#TypeParser.parse-1163"><span class="linenos">1163</span></a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
</span><span id="TypeParser.parse-1164"><a href="#TypeParser.parse-1164"><span class="linenos">1164</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse-1165"><a href="#TypeParser.parse-1165"><span class="linenos">1165</span></a><span class="sd">			Parse a string and convert it to its underlying type</span>
</span><span id="TypeParser.parse-1166"><a href="#TypeParser.parse-1166"><span class="linenos">1166</span></a>
</span><span id="TypeParser.parse-1167"><a href="#TypeParser.parse-1167"><span class="linenos">1167</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse-1168"><a href="#TypeParser.parse-1168"><span class="linenos">1168</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse-1169"><a href="#TypeParser.parse-1169"><span class="linenos">1169</span></a><span class="sd">			`value`</span>
</span><span id="TypeParser.parse-1170"><a href="#TypeParser.parse-1170"><span class="linenos">1170</span></a><span class="sd">			: the string to be parsed</span>
</span><span id="TypeParser.parse-1171"><a href="#TypeParser.parse-1171"><span class="linenos">1171</span></a>
</span><span id="TypeParser.parse-1172"><a href="#TypeParser.parse-1172"><span class="linenos">1172</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse-1173"><a href="#TypeParser.parse-1173"><span class="linenos">1173</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse-1174"><a href="#TypeParser.parse-1174"><span class="linenos">1174</span></a><span class="sd">			converted value</span>
</span><span id="TypeParser.parse-1175"><a href="#TypeParser.parse-1175"><span class="linenos">1175</span></a>
</span><span id="TypeParser.parse-1176"><a href="#TypeParser.parse-1176"><span class="linenos">1176</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse-1177"><a href="#TypeParser.parse-1177"><span class="linenos">1177</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse-1178"><a href="#TypeParser.parse-1178"><span class="linenos">1178</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse-1179"><a href="#TypeParser.parse-1179"><span class="linenos">1179</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.parse-1180"><a href="#TypeParser.parse-1180"><span class="linenos">1180</span></a><span class="sd">			parser.parse(&quot;true&quot;)  # True</span>
</span><span id="TypeParser.parse-1181"><a href="#TypeParser.parse-1181"><span class="linenos">1181</span></a><span class="sd">			parser.parse(&quot;2.0&quot;)   # 2.</span>
</span><span id="TypeParser.parse-1182"><a href="#TypeParser.parse-1182"><span class="linenos">1182</span></a><span class="sd">			parser.parse(&quot;abc&quot;)   # &quot;abc&quot;</span>
</span><span id="TypeParser.parse-1183"><a href="#TypeParser.parse-1183"><span class="linenos">1183</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse-1184"><a href="#TypeParser.parse-1184"><span class="linenos">1184</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse-1185"><a href="#TypeParser.parse-1185"><span class="linenos">1185</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a string and convert it to its underlying type</p>

<h2 id="arguments">Arguments</h2>

<p><code>value</code>
: the string to be parsed</p>

<h2 id="returns">Returns</h2>

<p>converted value</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">)</span>   <span class="c1"># 2.</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>   <span class="c1"># &quot;abc&quot;</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse_series" class="classattr">
                                        <input id="TypeParser.parse_series-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_series</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_series-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_series"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_series-1188"><a href="#TypeParser.parse_series-1188"><span class="linenos">1188</span></a>	<span class="k">def</span> <span class="nf">parse_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]:</span>
</span><span id="TypeParser.parse_series-1189"><a href="#TypeParser.parse_series-1189"><span class="linenos">1189</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_series-1190"><a href="#TypeParser.parse_series-1190"><span class="linenos">1190</span></a><span class="sd">			Parse a series of strings and convert them to their underlying common type</span>
</span><span id="TypeParser.parse_series-1191"><a href="#TypeParser.parse_series-1191"><span class="linenos">1191</span></a>
</span><span id="TypeParser.parse_series-1192"><a href="#TypeParser.parse_series-1192"><span class="linenos">1192</span></a><span class="sd">			If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser.parse_series-1193"><a href="#TypeParser.parse_series-1193"><span class="linenos">1193</span></a>
</span><span id="TypeParser.parse_series-1194"><a href="#TypeParser.parse_series-1194"><span class="linenos">1194</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_series-1195"><a href="#TypeParser.parse_series-1195"><span class="linenos">1195</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_series-1196"><a href="#TypeParser.parse_series-1196"><span class="linenos">1196</span></a><span class="sd">			`values`</span>
</span><span id="TypeParser.parse_series-1197"><a href="#TypeParser.parse_series-1197"><span class="linenos">1197</span></a><span class="sd">			: series of strings to be parsed</span>
</span><span id="TypeParser.parse_series-1198"><a href="#TypeParser.parse_series-1198"><span class="linenos">1198</span></a>
</span><span id="TypeParser.parse_series-1199"><a href="#TypeParser.parse_series-1199"><span class="linenos">1199</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_series-1200"><a href="#TypeParser.parse_series-1200"><span class="linenos">1200</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_series-1201"><a href="#TypeParser.parse_series-1201"><span class="linenos">1201</span></a><span class="sd">			converted values</span>
</span><span id="TypeParser.parse_series-1202"><a href="#TypeParser.parse_series-1202"><span class="linenos">1202</span></a>
</span><span id="TypeParser.parse_series-1203"><a href="#TypeParser.parse_series-1203"><span class="linenos">1203</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_series-1204"><a href="#TypeParser.parse_series-1204"><span class="linenos">1204</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_series-1205"><a href="#TypeParser.parse_series-1205"><span class="linenos">1205</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_series-1206"><a href="#TypeParser.parse_series-1206"><span class="linenos">1206</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.parse_series-1207"><a href="#TypeParser.parse_series-1207"><span class="linenos">1207</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])        # [1, 2, 3]</span>
</span><span id="TypeParser.parse_series-1208"><a href="#TypeParser.parse_series-1208"><span class="linenos">1208</span></a><span class="sd">			parser.parse_series([&quot;5&quot;, &quot;6.7&quot;, &quot;8.&quot;])     # [5., 6.7, 8.]</span>
</span><span id="TypeParser.parse_series-1209"><a href="#TypeParser.parse_series-1209"><span class="linenos">1209</span></a><span class="sd">			parser.parse_series([&quot;true&quot;, &quot;false&quot;, &quot;&quot;])  # [True, False, None]</span>
</span><span id="TypeParser.parse_series-1210"><a href="#TypeParser.parse_series-1210"><span class="linenos">1210</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])    # [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
</span><span id="TypeParser.parse_series-1211"><a href="#TypeParser.parse_series-1211"><span class="linenos">1211</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_series-1212"><a href="#TypeParser.parse_series-1212"><span class="linenos">1212</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_series-1213"><a href="#TypeParser.parse_series-1213"><span class="linenos">1213</span></a>		<span class="n">inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</span><span id="TypeParser.parse_series-1214"><a href="#TypeParser.parse_series-1214"><span class="linenos">1214</span></a>		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a series of strings and convert them to their underlying common type</p>

<p>If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>

<h2 id="arguments">Arguments</h2>

<p><code>values</code>
: series of strings to be parsed</p>

<h2 id="returns">Returns</h2>

<p>converted values</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_series</span><span class="p">([</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">])</span>        <span class="c1"># [1, 2, 3]</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_series</span><span class="p">([</span><span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6.7&quot;</span><span class="p">,</span> <span class="s2">&quot;8.&quot;</span><span class="p">])</span>     <span class="c1"># [5., 6.7, 8.]</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_series</span><span class="p">([</span><span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">])</span>  <span class="c1"># [True, False, None]</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse_series</span><span class="p">([</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">])</span>    <span class="c1"># [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.parse_table" class="classattr">
                                        <input id="TypeParser.parse_table-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">parse_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.parse_table-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.parse_table"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_table-1217"><a href="#TypeParser.parse_table-1217"><span class="linenos">1217</span></a>	<span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
</span><span id="TypeParser.parse_table-1218"><a href="#TypeParser.parse_table-1218"><span class="linenos">1218</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_table-1219"><a href="#TypeParser.parse_table-1219"><span class="linenos">1219</span></a><span class="sd">			Parse a table of strings and convert them to the underlying common type of each column</span>
</span><span id="TypeParser.parse_table-1220"><a href="#TypeParser.parse_table-1220"><span class="linenos">1220</span></a>
</span><span id="TypeParser.parse_table-1221"><a href="#TypeParser.parse_table-1221"><span class="linenos">1221</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser.parse_table-1222"><a href="#TypeParser.parse_table-1222"><span class="linenos">1222</span></a>
</span><span id="TypeParser.parse_table-1223"><a href="#TypeParser.parse_table-1223"><span class="linenos">1223</span></a><span class="sd">			Note that the type to which the values should be converted is determined by `infer_table()`, and so the individual inferred types of every value in the table must be able to fit into memory.</span>
</span><span id="TypeParser.parse_table-1224"><a href="#TypeParser.parse_table-1224"><span class="linenos">1224</span></a>
</span><span id="TypeParser.parse_table-1225"><a href="#TypeParser.parse_table-1225"><span class="linenos">1225</span></a><span class="sd">			This is a function that computes the entire table and returns it all at once. The generator function `iterate_table()` behaves analogously, except that it computes and yields each row one at a time instead.</span>
</span><span id="TypeParser.parse_table-1226"><a href="#TypeParser.parse_table-1226"><span class="linenos">1226</span></a>
</span><span id="TypeParser.parse_table-1227"><a href="#TypeParser.parse_table-1227"><span class="linenos">1227</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.parse_table-1228"><a href="#TypeParser.parse_table-1228"><span class="linenos">1228</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.parse_table-1229"><a href="#TypeParser.parse_table-1229"><span class="linenos">1229</span></a><span class="sd">			`rows`</span>
</span><span id="TypeParser.parse_table-1230"><a href="#TypeParser.parse_table-1230"><span class="linenos">1230</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
</span><span id="TypeParser.parse_table-1231"><a href="#TypeParser.parse_table-1231"><span class="linenos">1231</span></a>
</span><span id="TypeParser.parse_table-1232"><a href="#TypeParser.parse_table-1232"><span class="linenos">1232</span></a><span class="sd">			`iterator`</span>
</span><span id="TypeParser.parse_table-1233"><a href="#TypeParser.parse_table-1233"><span class="linenos">1233</span></a><span class="sd">			: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</span>
</span><span id="TypeParser.parse_table-1234"><a href="#TypeParser.parse_table-1234"><span class="linenos">1234</span></a>
</span><span id="TypeParser.parse_table-1235"><a href="#TypeParser.parse_table-1235"><span class="linenos">1235</span></a><span class="sd">			Returns</span>
</span><span id="TypeParser.parse_table-1236"><a href="#TypeParser.parse_table-1236"><span class="linenos">1236</span></a><span class="sd">			-------</span>
</span><span id="TypeParser.parse_table-1237"><a href="#TypeParser.parse_table-1237"><span class="linenos">1237</span></a><span class="sd">			converted table of values, in row-major order</span>
</span><span id="TypeParser.parse_table-1238"><a href="#TypeParser.parse_table-1238"><span class="linenos">1238</span></a>
</span><span id="TypeParser.parse_table-1239"><a href="#TypeParser.parse_table-1239"><span class="linenos">1239</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.parse_table-1240"><a href="#TypeParser.parse_table-1240"><span class="linenos">1240</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.parse_table-1241"><a href="#TypeParser.parse_table-1241"><span class="linenos">1241</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.parse_table-1242"><a href="#TypeParser.parse_table-1242"><span class="linenos">1242</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.parse_table-1243"><a href="#TypeParser.parse_table-1243"><span class="linenos">1243</span></a><span class="sd">			table = parser.parse_table([</span>
</span><span id="TypeParser.parse_table-1244"><a href="#TypeParser.parse_table-1244"><span class="linenos">1244</span></a><span class="sd">				[&quot;1&quot;, &quot;5&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
</span><span id="TypeParser.parse_table-1245"><a href="#TypeParser.parse_table-1245"><span class="linenos">1245</span></a><span class="sd">				[&quot;2&quot;, &quot;6.7&quot;, &quot;false&quot;, &quot;2.3&quot;],</span>
</span><span id="TypeParser.parse_table-1246"><a href="#TypeParser.parse_table-1246"><span class="linenos">1246</span></a><span class="sd">				[&quot;3&quot;, &quot;8.0&quot;, &quot;&quot;,      &quot;abc&quot;],</span>
</span><span id="TypeParser.parse_table-1247"><a href="#TypeParser.parse_table-1247"><span class="linenos">1247</span></a><span class="sd">			]):</span>
</span><span id="TypeParser.parse_table-1248"><a href="#TypeParser.parse_table-1248"><span class="linenos">1248</span></a><span class="sd">			assert table == [</span>
</span><span id="TypeParser.parse_table-1249"><a href="#TypeParser.parse_table-1249"><span class="linenos">1249</span></a><span class="sd">				[1, 5.,  True,  &quot;1&quot;],</span>
</span><span id="TypeParser.parse_table-1250"><a href="#TypeParser.parse_table-1250"><span class="linenos">1250</span></a><span class="sd">				[2, 6.7, False, &quot;2.3&quot;],</span>
</span><span id="TypeParser.parse_table-1251"><a href="#TypeParser.parse_table-1251"><span class="linenos">1251</span></a><span class="sd">				[3, 8.,  None,  &quot;abc&quot;],</span>
</span><span id="TypeParser.parse_table-1252"><a href="#TypeParser.parse_table-1252"><span class="linenos">1252</span></a><span class="sd">			]</span>
</span><span id="TypeParser.parse_table-1253"><a href="#TypeParser.parse_table-1253"><span class="linenos">1253</span></a><span class="sd">			```</span>
</span><span id="TypeParser.parse_table-1254"><a href="#TypeParser.parse_table-1254"><span class="linenos">1254</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.parse_table-1255"><a href="#TypeParser.parse_table-1255"><span class="linenos">1255</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">converted_row</span> <span class="k">for</span> <span class="n">converted_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a table of strings and convert them to the underlying common type of each column</p>

<p>For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>

<p>Note that the type to which the values should be converted is determined by <code><a href="#TypeParser.infer_table">infer_table()</a></code>, and so the individual inferred types of every value in the table must be able to fit into memory.</p>

<p>This is a function that computes the entire table and returns it all at once. The generator function <code><a href="#TypeParser.iterate_table">iterate_table()</a></code> behaves analogously, except that it computes and yields each row one at a time instead.</p>

<h2 id="arguments">Arguments</h2>

<p><code>rows</code>
: table of strings to be parsed, in row-major order</p>

<p><code>iterator</code>
: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</p>

<h2 id="returns">Returns</h2>

<p>converted table of values, in row-major order</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_table</span><span class="p">([</span>
	<span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span>   <span class="s2">&quot;true&quot;</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;6.7&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;8.0&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>      <span class="s2">&quot;abc&quot;</span><span class="p">],</span>
<span class="p">]):</span>
<span class="k">assert</span> <span class="n">table</span> <span class="o">==</span> <span class="p">[</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span>  <span class="kc">None</span><span class="p">,</span>  <span class="s2">&quot;abc&quot;</span><span class="p">],</span>
<span class="p">]</span>
</code></pre>
</div></div>


                            </div>
                            <div id="TypeParser.iterate_table" class="classattr">
                                        <input id="TypeParser.iterate_table-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">iterate_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]]</span>:</span></span>


                <label class="view-source-button" for="TypeParser.iterate_table-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#TypeParser.iterate_table"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.iterate_table-1258"><a href="#TypeParser.iterate_table-1258"><span class="linenos">1258</span></a>	<span class="k">def</span> <span class="nf">iterate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
</span><span id="TypeParser.iterate_table-1259"><a href="#TypeParser.iterate_table-1259"><span class="linenos">1259</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="TypeParser.iterate_table-1260"><a href="#TypeParser.iterate_table-1260"><span class="linenos">1260</span></a><span class="sd">			Parse a table of strings for the underlying common type of each column, then convert and yield each row</span>
</span><span id="TypeParser.iterate_table-1261"><a href="#TypeParser.iterate_table-1261"><span class="linenos">1261</span></a>
</span><span id="TypeParser.iterate_table-1262"><a href="#TypeParser.iterate_table-1262"><span class="linenos">1262</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
</span><span id="TypeParser.iterate_table-1263"><a href="#TypeParser.iterate_table-1263"><span class="linenos">1263</span></a>
</span><span id="TypeParser.iterate_table-1264"><a href="#TypeParser.iterate_table-1264"><span class="linenos">1264</span></a><span class="sd">			This is a generator function that computes and yields each row one at a time. However, note that in order to determine the types to which each column should be converted, the individual inferred types of every value in the table must still be able to fit into memory.</span>
</span><span id="TypeParser.iterate_table-1265"><a href="#TypeParser.iterate_table-1265"><span class="linenos">1265</span></a>
</span><span id="TypeParser.iterate_table-1266"><a href="#TypeParser.iterate_table-1266"><span class="linenos">1266</span></a><span class="sd">			The function `parse_table()` behaves analogously, except that it computes the entire table and returns it as a list of lists instead.</span>
</span><span id="TypeParser.iterate_table-1267"><a href="#TypeParser.iterate_table-1267"><span class="linenos">1267</span></a>
</span><span id="TypeParser.iterate_table-1268"><a href="#TypeParser.iterate_table-1268"><span class="linenos">1268</span></a><span class="sd">			Arguments</span>
</span><span id="TypeParser.iterate_table-1269"><a href="#TypeParser.iterate_table-1269"><span class="linenos">1269</span></a><span class="sd">			---------</span>
</span><span id="TypeParser.iterate_table-1270"><a href="#TypeParser.iterate_table-1270"><span class="linenos">1270</span></a><span class="sd">			`rows`</span>
</span><span id="TypeParser.iterate_table-1271"><a href="#TypeParser.iterate_table-1271"><span class="linenos">1271</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
</span><span id="TypeParser.iterate_table-1272"><a href="#TypeParser.iterate_table-1272"><span class="linenos">1272</span></a>
</span><span id="TypeParser.iterate_table-1273"><a href="#TypeParser.iterate_table-1273"><span class="linenos">1273</span></a><span class="sd">			Yields</span>
</span><span id="TypeParser.iterate_table-1274"><a href="#TypeParser.iterate_table-1274"><span class="linenos">1274</span></a><span class="sd">			------</span>
</span><span id="TypeParser.iterate_table-1275"><a href="#TypeParser.iterate_table-1275"><span class="linenos">1275</span></a><span class="sd">			each row of converted table values</span>
</span><span id="TypeParser.iterate_table-1276"><a href="#TypeParser.iterate_table-1276"><span class="linenos">1276</span></a>
</span><span id="TypeParser.iterate_table-1277"><a href="#TypeParser.iterate_table-1277"><span class="linenos">1277</span></a><span class="sd">			Examples</span>
</span><span id="TypeParser.iterate_table-1278"><a href="#TypeParser.iterate_table-1278"><span class="linenos">1278</span></a><span class="sd">			--------</span>
</span><span id="TypeParser.iterate_table-1279"><a href="#TypeParser.iterate_table-1279"><span class="linenos">1279</span></a><span class="sd">			```python</span>
</span><span id="TypeParser.iterate_table-1280"><a href="#TypeParser.iterate_table-1280"><span class="linenos">1280</span></a><span class="sd">			parser = TypeParser()</span>
</span><span id="TypeParser.iterate_table-1281"><a href="#TypeParser.iterate_table-1281"><span class="linenos">1281</span></a><span class="sd">			table = parser.iterate_table([</span>
</span><span id="TypeParser.iterate_table-1282"><a href="#TypeParser.iterate_table-1282"><span class="linenos">1282</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
</span><span id="TypeParser.iterate_table-1283"><a href="#TypeParser.iterate_table-1283"><span class="linenos">1283</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
</span><span id="TypeParser.iterate_table-1284"><a href="#TypeParser.iterate_table-1284"><span class="linenos">1284</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
</span><span id="TypeParser.iterate_table-1285"><a href="#TypeParser.iterate_table-1285"><span class="linenos">1285</span></a><span class="sd">			]):</span>
</span><span id="TypeParser.iterate_table-1286"><a href="#TypeParser.iterate_table-1286"><span class="linenos">1286</span></a><span class="sd">			assert next(table) == [1.,  1, &quot;1&quot;]</span>
</span><span id="TypeParser.iterate_table-1287"><a href="#TypeParser.iterate_table-1287"><span class="linenos">1287</span></a><span class="sd">			assert next(table) == [2.,  0, &quot;2.3&quot;]</span>
</span><span id="TypeParser.iterate_table-1288"><a href="#TypeParser.iterate_table-1288"><span class="linenos">1288</span></a><span class="sd">			assert next(table) == [3.4, 2, &quot;abc&quot;]</span>
</span><span id="TypeParser.iterate_table-1289"><a href="#TypeParser.iterate_table-1289"><span class="linenos">1289</span></a><span class="sd">			```</span>
</span><span id="TypeParser.iterate_table-1290"><a href="#TypeParser.iterate_table-1290"><span class="linenos">1290</span></a><span class="sd">		&quot;&quot;&quot;</span>
</span><span id="TypeParser.iterate_table-1291"><a href="#TypeParser.iterate_table-1291"><span class="linenos">1291</span></a>		<span class="n">inferred_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span><span id="TypeParser.iterate_table-1292"><a href="#TypeParser.iterate_table-1292"><span class="linenos">1292</span></a>
</span><span id="TypeParser.iterate_table-1293"><a href="#TypeParser.iterate_table-1293"><span class="linenos">1293</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
</span><span id="TypeParser.iterate_table-1294"><a href="#TypeParser.iterate_table-1294"><span class="linenos">1294</span></a>			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">inferred_types</span><span class="p">)]</span>
</span></pre></div>


    <div class="docstring">
<p>Parse a table of strings for the underlying common type of each column, then convert and yield each row</p>

<p>For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>

<p>This is a generator function that computes and yields each row one at a time. However, note that in order to determine the types to which each column should be converted, the individual inferred types of every value in the table must still be able to fit into memory.</p>

<p>The function <code><a href="#TypeParser.parse_table">parse_table()</a></code> behaves analogously, except that it computes the entire table and returns it as a list of lists instead.</p>

<h2 id="arguments">Arguments</h2>

<p><code>rows</code>
: table of strings to be parsed, in row-major order</p>

<h2 id="yields">Yields</h2>

<p>each row of converted table values</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">parser</span> <span class="o">=</span> <span class="n">TypeParser</span><span class="p">()</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">([</span>
	<span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span>   <span class="s2">&quot;true&quot;</span><span class="p">,</span>  <span class="s2">&quot;1&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">,</span>   <span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">],</span>
	<span class="p">[</span><span class="s2">&quot;3.4&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span>     <span class="s2">&quot;abc&quot;</span><span class="p">],</span>
<span class="p">]):</span>
<span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">]</span>
<span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;2.3&quot;</span><span class="p">]</span>
<span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mf">3.4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">]</span>
</code></pre>
</div></div>


                            </div>
                </section>
                <section id="reduce_types">
                            <input id="reduce_types-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">reduce_types</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="n">types</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n"><a href="#Nullable">Nullable</a></span><span class="p">,</span> <span class="nb">list</span><span class="p">]]]</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n"><a href="#Nullable">Nullable</a></span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span>:</span></span>


                <label class="view-source-button" for="reduce_types-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#reduce_types"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="reduce_types-156"><a href="#reduce_types-156"><span class="linenos">156</span></a><span class="k">def</span> <span class="nf">reduce_types</span><span class="p">(</span><span class="n">types</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
</span><span id="reduce_types-157"><a href="#reduce_types-157"><span class="linenos">157</span></a><span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="reduce_types-158"><a href="#reduce_types-158"><span class="linenos">158</span></a><span class="sd">		Reduce multiple types into a single common type.</span>
</span><span id="reduce_types-159"><a href="#reduce_types-159"><span class="linenos">159</span></a>
</span><span id="reduce_types-160"><a href="#reduce_types-160"><span class="linenos">160</span></a><span class="sd">		If the input types are not all the same, the resulting type will be narrowest possible type that will encompass all of the input types.</span>
</span><span id="reduce_types-161"><a href="#reduce_types-161"><span class="linenos">161</span></a>
</span><span id="reduce_types-162"><a href="#reduce_types-162"><span class="linenos">162</span></a><span class="sd">		This operation is useful in cases such as parsing a CSV file where each column should have a consistent type, but where the individual values in a column could be interpreted variously as ints or floats (or other types).</span>
</span><span id="reduce_types-163"><a href="#reduce_types-163"><span class="linenos">163</span></a>
</span><span id="reduce_types-164"><a href="#reduce_types-164"><span class="linenos">164</span></a><span class="sd">		Arguments</span>
</span><span id="reduce_types-165"><a href="#reduce_types-165"><span class="linenos">165</span></a><span class="sd">		---------</span>
</span><span id="reduce_types-166"><a href="#reduce_types-166"><span class="linenos">166</span></a><span class="sd">		`types`</span>
</span><span id="reduce_types-167"><a href="#reduce_types-167"><span class="linenos">167</span></a><span class="sd">		: types to be reduced</span>
</span><span id="reduce_types-168"><a href="#reduce_types-168"><span class="linenos">168</span></a>
</span><span id="reduce_types-169"><a href="#reduce_types-169"><span class="linenos">169</span></a><span class="sd">		Returns</span>
</span><span id="reduce_types-170"><a href="#reduce_types-170"><span class="linenos">170</span></a><span class="sd">		-------</span>
</span><span id="reduce_types-171"><a href="#reduce_types-171"><span class="linenos">171</span></a><span class="sd">		common reduced type</span>
</span><span id="reduce_types-172"><a href="#reduce_types-172"><span class="linenos">172</span></a>
</span><span id="reduce_types-173"><a href="#reduce_types-173"><span class="linenos">173</span></a><span class="sd">		Examples</span>
</span><span id="reduce_types-174"><a href="#reduce_types-174"><span class="linenos">174</span></a><span class="sd">		--------</span>
</span><span id="reduce_types-175"><a href="#reduce_types-175"><span class="linenos">175</span></a><span class="sd">		```python</span>
</span><span id="reduce_types-176"><a href="#reduce_types-176"><span class="linenos">176</span></a><span class="sd">		reduce_types([int, float])        # float</span>
</span><span id="reduce_types-177"><a href="#reduce_types-177"><span class="linenos">177</span></a><span class="sd">		reduce_types([bool, int])         # int</span>
</span><span id="reduce_types-178"><a href="#reduce_types-178"><span class="linenos">178</span></a><span class="sd">		reduce_types([int, float, str])   # str</span>
</span><span id="reduce_types-179"><a href="#reduce_types-179"><span class="linenos">179</span></a><span class="sd">		```</span>
</span><span id="reduce_types-180"><a href="#reduce_types-180"><span class="linenos">180</span></a><span class="sd">	&quot;&quot;&quot;</span>
</span><span id="reduce_types-181"><a href="#reduce_types-181"><span class="linenos">181</span></a>	<span class="n">reduced_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="reduce_types-182"><a href="#reduce_types-182"><span class="linenos">182</span></a>	<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
</span><span id="reduce_types-183"><a href="#reduce_types-183"><span class="linenos">183</span></a>		<span class="k">if</span> <span class="n">reduced_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="reduce_types-184"><a href="#reduce_types-184"><span class="linenos">184</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">t</span>
</span><span id="reduce_types-185"><a href="#reduce_types-185"><span class="linenos">185</span></a>		<span class="k">elif</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">reduced_type</span><span class="p">:</span>
</span><span id="reduce_types-186"><a href="#reduce_types-186"><span class="linenos">186</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">_merge_types</span><span class="p">(</span><span class="n">reduced_type</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</span><span id="reduce_types-187"><a href="#reduce_types-187"><span class="linenos">187</span></a>		<span class="k">if</span> <span class="n">reduced_type</span> <span class="o">==</span> <span class="n">_TerminalValue</span><span class="p">:</span>
</span><span id="reduce_types-188"><a href="#reduce_types-188"><span class="linenos">188</span></a>			<span class="k">return</span> <span class="n">_TerminalValue</span>
</span><span id="reduce_types-189"><a href="#reduce_types-189"><span class="linenos">189</span></a>
</span><span id="reduce_types-190"><a href="#reduce_types-190"><span class="linenos">190</span></a>	<span class="k">if</span> <span class="n">reduced_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="reduce_types-191"><a href="#reduce_types-191"><span class="linenos">191</span></a>		<span class="c1"># types is empty</span>
</span><span id="reduce_types-192"><a href="#reduce_types-192"><span class="linenos">192</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
</span><span id="reduce_types-193"><a href="#reduce_types-193"><span class="linenos">193</span></a>	<span class="k">else</span><span class="p">:</span>
</span><span id="reduce_types-194"><a href="#reduce_types-194"><span class="linenos">194</span></a>		<span class="k">return</span> <span class="n">reduced_type</span>
</span></pre></div>


    <div class="docstring">
<p>Reduce multiple types into a single common type.</p>

<p>If the input types are not all the same, the resulting type will be narrowest possible type that will encompass all of the input types.</p>

<p>This operation is useful in cases such as parsing a CSV file where each column should have a consistent type, but where the individual values in a column could be interpreted variously as ints or floats (or other types).</p>

<h2 id="arguments">Arguments</h2>

<p><code>types</code>
: types to be reduced</p>

<h2 id="returns">Returns</h2>

<p>common reduced type</p>

<h2 id="examples">Examples</h2>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">reduce_types</span><span class="p">([</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>        <span class="c1"># float</span>
<span class="n">reduce_types</span><span class="p">([</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>         <span class="c1"># int</span>
<span class="n">reduce_types</span><span class="p">([</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span>   <span class="c1"># str</span>
</code></pre>
</div></div>


                </section>
                <section id="Nullable">
                            <input id="Nullable-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">Nullable</span><wbr>(<span class="base">typing.Generic[~S]</span>):


                <label class="view-source-button" for="Nullable-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#Nullable"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Nullable-22"><a href="#Nullable-22"><span class="linenos">22</span></a><span class="k">class</span> <span class="nc">Nullable</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">S</span><span class="p">]):</span>
</span><span id="Nullable-23"><a href="#Nullable-23"><span class="linenos">23</span></a><span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="Nullable-24"><a href="#Nullable-24"><span class="linenos">24</span></a><span class="sd">		Dummy container type that represents a scalar (`S`) that could also be None</span>
</span><span id="Nullable-25"><a href="#Nullable-25"><span class="linenos">25</span></a>
</span><span id="Nullable-26"><a href="#Nullable-26"><span class="linenos">26</span></a><span class="sd">		The type annotation `Nullable[S]` is treated as equivalent to `Union[S, types.NoneType]`, which will accept either a value of type `S` or the value `None`.</span>
</span><span id="Nullable-27"><a href="#Nullable-27"><span class="linenos">27</span></a>
</span><span id="Nullable-28"><a href="#Nullable-28"><span class="linenos">28</span></a><span class="sd">		This class should not be instantiated.</span>
</span><span id="Nullable-29"><a href="#Nullable-29"><span class="linenos">29</span></a><span class="sd">	&quot;&quot;&quot;</span>
</span><span id="Nullable-30"><a href="#Nullable-30"><span class="linenos">30</span></a>	<span class="k">pass</span>
</span></pre></div>


    <div class="docstring">
<p>Dummy container type that represents a scalar (<code>S</code>) that could also be None</p>

<p>The type annotation <code>Nullable[S]</code> is treated as equivalent to <code>Union[S, types.NoneType]</code>, which will accept either a value of type <code>S</code> or the value <code>None</code>.</p>

<p>This class should not be instantiated.</p></div>


                </section>
    </main>
</body>
</html>